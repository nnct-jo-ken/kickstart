<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Kickstart Programming</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Kickstart Programming</a></li><li class="chapter-item expanded "><a href="wsl_environment/chapter_1.html"><strong aria-hidden="true">2.</strong> WSL2の環境構築</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> プログラミング入門</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="Processing/chapter_01.html"><strong aria-hidden="true">3.1.</strong> Chapter 1:Processingを始めよう</a></li><li class="chapter-item expanded "><a href="Processing/chapter_02.html"><strong aria-hidden="true">3.2.</strong> Chapter 2:図形を描いてみよう</a></li><li class="chapter-item expanded "><a href="Processing/chapter_03.html"><strong aria-hidden="true">3.3.</strong> Chapter 3:変数</a></li><li class="chapter-item expanded "><a href="Processing/chapter_04.html"><strong aria-hidden="true">3.4.</strong> Chapter 4:動きを作る</a></li><li class="chapter-item expanded "><a href="Processing/chapter_05.html"><strong aria-hidden="true">3.5.</strong> Chapter 5:分岐処理</a></li><li class="chapter-item expanded "><a href="Processing/chapter_06.html"><strong aria-hidden="true">3.6.</strong> Chapter 6:繰り返し処理</a></li><li class="chapter-item expanded "><a href="Processing/chapter_07.html"><strong aria-hidden="true">3.7.</strong> Chapter 7:関数を作る</a></li><li class="chapter-item expanded "><a href="Processing/chapter_08.html"><strong aria-hidden="true">3.8.</strong> Chapter 8:配列</a></li><li class="chapter-item expanded "><a href="Processing/chapter_09.html"><strong aria-hidden="true">3.9.</strong> Chapter 9:クラスとメンバ</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> ゲームを作ってみよう</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="ProcessingGame/Game_01.html"><strong aria-hidden="true">4.1.</strong> Game 1:単発避けゲー</a></li><li class="chapter-item expanded "><a href="ProcessingGame/Game_02.html"><strong aria-hidden="true">4.2.</strong> Game 2:鳥のゲーム</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> 発展</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="ProcessingChallenge/sqrt.html"><strong aria-hidden="true">5.1.</strong> 平方根</a></li><li class="chapter-item expanded "><a href="ProcessingChallenge/fractal.html"><strong aria-hidden="true">5.2.</strong> 再帰処理でフラクタル図形</a></li><li class="chapter-item expanded "><a href="ProcessingChallenge/sin.html"><strong aria-hidden="true">5.3.</strong> 三角関数</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> 補足資料</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="ProcessingOther/color.html"><strong aria-hidden="true">6.1.</strong> コンピュータ上での色の表現</a></li><li class="chapter-item expanded "><a href="ProcessingOther/var.html"><strong aria-hidden="true">6.2.</strong> 変数の詳しい話</a></li><li class="chapter-item expanded "><a href="ProcessingOther/operator.html"><strong aria-hidden="true">6.3.</strong> 演算子</a></li><li class="chapter-item expanded "><a href="ProcessingOther/scratch.html"><strong aria-hidden="true">6.4.</strong> Scratchの命令に置き換えると？</a></li><li class="chapter-item expanded "><a href="ProcessingOther/next.html"><strong aria-hidden="true">6.5.</strong> Processingの次は？</a></li></ol></li><li class="chapter-item expanded "><a href="ProcessingSample/all.html"><strong aria-hidden="true">7.</strong> サンプルプログラム</a></li><li class="chapter-item expanded "><a href="git/index.html"><strong aria-hidden="true">8.</strong> Git / GitHub講座</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="git/01_setup.html"><strong aria-hidden="true">8.1.</strong> Git / GitHubを始める準備</a></li><li class="chapter-item expanded "><a href="git/02_git_summary.html"><strong aria-hidden="true">8.2.</strong> Git概要</a></li><li class="chapter-item expanded "><a href="git/03_first_git_commit.html"><strong aria-hidden="true">8.3.</strong> 初めてのコミット</a></li><li class="chapter-item expanded "><a href="git/04_first_github_push.html"><strong aria-hidden="true">8.4.</strong> 初めてのプッシュ</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Kickstart Programming</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="kickstart-programming"><a class="header" href="#kickstart-programming">Kickstart Programming</a></h1>
<p><strong>著者: <a href="https://github.com/shun-shobon">Shuntaro Nishizawa</a>, <a href="https://github.com/Shibaken28">Shibaken28</a>, <a href="https://github.com/hiroki-1219">hiroki-1219</a>, <a href="https://github.com/yu1hpa">yu1hpa</a></strong></p>
<p>この資料は長野高専情報技術研究部の新入部員向けの資料です。
新入部員向けにプログラミングの基礎から、Linuxコマンド、Git/GitHubなど様々ことについて記載しています。</p>
<p>もし資料にミスや不明な点等があれば、<a href="https://github.com/nnct-jo-ken/kickstart">このリポジトリ</a>にIssueとしてご報告ください。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wsl2とは"><a class="header" href="#wsl2とは">WSL2とは</a></h1>
<p>WSL2(Windows Subsystem for Linux 2)は、Windows10上でLinuxを動作させることができる仕組みです。(LinuxはWindowsと同じOSの一種です。詳細については他の資料を参照してください。)</p>
<!---他の資料をLinuxについての資料のハイパーリンクにする
また、他の資料を他の言葉に変更--->
<p>（J科生はCygwinを学校で導入したと思います。これとWSL2は似ている存在ではありますが、実現方法は全く違います。また、利点はCygwinよりもWSL2のほうが多いです。）</p>
<p>利点としては、以下の例が挙げられます。</p>
<ul>
<li>ファイルにアクセスする速度が早い</li>
<li>原理上Linuxと100%の互換性がある</li>
<li>Linuxと互換性があるため、Linuxの機能は全て使える</li>
</ul>
<p>以上の利点から、ここではWSL2を導入していきます。
（CygwinはWSL2を導入しても使うことができるので、アンインストールする必要はありません。）</p>
<h1 id="wsl2の導入"><a class="header" href="#wsl2の導入">WSL2の導入</a></h1>
<p>WSL2を導入していきます。導入は<a href="https://docs.microsoft.com/ja-jp/windows/wsl/install-win10">Microsoftの公式ドキュメント</a>の手順で行っていきます。</p>
<h2 id="1linux用windowsサブシステムを有効にする"><a class="header" href="#1linux用windowsサブシステムを有効にする">1.Linux用Windowsサブシステムを有効にする</a></h2>
<p>Windows上にLinuxディストリビューションをインストールする前に、まず
&quot;Linux用Windowsサブシステム&quot;を有効にする必要があります。</p>
<p>はじめに、管理者としてPowerShellを開きます。</p>
<p>Windowsの検索窓からPowerShellと入力し、「管理者として実行する」を選択してください。</p>
<img src="wsl_environment/./img/powershell_sudo.png" width=75%>
<p>選択した後、「このアプリがデバイスに変更を加えることを許可しますか？」と尋ねられるので、「はい」を選択してください。</p>
<p>PowerShellが起動したら、以下のコマンドを実行してください。</p>
<pre><code>dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart
</code></pre>
<img src="wsl_environment/./img/powershell_wsl.png" width=75%>
<p>「操作は正常に完了しました。」と表示されたら、&quot;Linux用Windowsサブシステム&quot;が有効になりました。次の手順に進みましょう。</p>
<h2 id="2wsl2の実行に関する要件を確認する"><a class="header" href="#2wsl2の実行に関する要件を確認する">2.WSL2の実行に関する要件を確認する</a></h2>
<p>WSL2は、以下のシステム要件が必要です。</p>
<ul>
<li>x64システムの場合:バージョン1903以降、ビルド18362以上</li>
<li>ARM64システムの場合:バージョン2004以降、ビルド19041以上</li>
</ul>
<p>設定からシステム&gt;詳細情報へ進んで、&quot;システムの種類&quot;・&quot;バージョン&quot;・&quot;OSビルド&quot;を
確認してください。</p>
<img src="wsl_environment/./img/winver.png" width=75%>
<p>上記のシステム要件を満たしていることを確認できたら、次の手順に進みましょう。</p>
<h2 id="3仮想マシンの機能を有効にする"><a class="header" href="#3仮想マシンの機能を有効にする">3.仮想マシンの機能を有効にする</a></h2>
<p>WSL2をインストールする前に、&quot;仮想マシンプラットフォーム&quot;を有効にする必要があります。</p>
<p>PowerShellを閉じた場合は、もう一度管理者としてPowerShellを開いてください。</p>
<p>PowerShellで以下のコマンドを実行してください。</p>
<pre><code>dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart
</code></pre>
<img src="wsl_environment/./img/powershell_vm.png" width=75%>
<p>「操作が正常に完了しました。」と表示されたら、仮想マシンプラットフォームが有効になりました。</p>
<p>有効化したことを確認したら、コンピュータを再起動してください。コンピュータを再起動しないと、Linux用Windowsサブシステムと仮想マシンプラットフォームは完全に有効化されません。</p>
<p>コンピュータが再起動できたら、次の手順に進みましょう。</p>
<h2 id="4linuxカーネル更新プログラムパッケージをダウンロードする"><a class="header" href="#4linuxカーネル更新プログラムパッケージをダウンロードする">4.Linuxカーネル更新プログラムパッケージをダウンロードする</a></h2>
<p>Linuxカーネル更新プログラムパッケージの最新のパッケージをダウンロードします。</p>
<p>&quot;2.WSL2の実行に関する要件を確認する&quot;で確認した&quot;システムの種類&quot;に応じて以下のパッケージをダウンロードしてください。</p>
<p><a href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi">x64マシン用WSL2 Linux カーネル更新プログラムパッケージ</a></p>
<p><a href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_arm64.msi">ARM64マシン用WSL2 Linux カーネル更新プログラムパッケージ</a></p>
<p>ダウンロードしたら、更新プログラムパッケージを実行します。</p>
<p>エクスプローラーを開いて、ダウンロードフォルダへ進み、&quot;wsl_update_x64.msi&quot;を実行し、更新プログラムパッケージをインストールしてください。（ブラウザから、ファイルを直接実行しても大丈夫です。）</p>
<img src="wsl_environment/./img/wsl_package_download.png" width=75%>
<p>（管理者特権のアクセス許可を求めるメッセージが表示される場合があるので、「はい」を選択して、このインストールを承認してください。）</p>
<p>インストールが完了すると、次のウィンドウが表示されます。</p>
<img src="wsl_environment/./img/wsl_update_setup.png" width=75%>
<p>表示されたら、&quot;Finish&quot;を選択し、次の手順に進みましょう。</p>
<h2 id="5wsl2を既定のバージョンとして設定する"><a class="header" href="#5wsl2を既定のバージョンとして設定する">5.WSL2を既定のバージョンとして設定する</a></h2>
<p>新しいLinuxディストリビューションをインストールする際の規定のバージョンとしてWSL2を設定します。</p>
<p>PowerShellを開いて（今回は管理者としてPowerShellを開く必要はありません）
以下のコマンドを実行してください。</p>
<pre><code>wsl --set-default-version 2
</code></pre>
<img src="wsl_environment/./img/wsl_setdefault2.png" width=75%>
<p>「WSL2との主な違いについては、https://aka.ms/wsl2を参照してください」と表示されたら、WSL2が既定バージョンに設定されました。次の手順に進みましょう。</p>
<h2 id="6選択したlinuxディストリビューションをインストールする"><a class="header" href="#6選択したlinuxディストリビューションをインストールする">6.選択したLinuxディストリビューションをインストールする</a></h2>
<p>ディストリビューションとはOSを構築するための必要な諸々のソフトも含めた配布形態のことです。今回は&quot;Ubuntu&quot;を選択します。（他にも、CentOS・KaliLinuxなどたくさんのディストリビューションがあります。）</p>
<p>Microsoft Storeを起動して&quot;Ubuntu&quot;と検索し、Ubuntuを選択してください。</p>
<img src="wsl_environment/./img/search_ubuntu.png" width=75%>
<p>表示されたページの「入手」を選択してください。Ubuntuのインストールが開始されます。
（下の画像では、Ubuntu 20.04 LTSになっていますが、操作は変わりません。）</p>
<img src="wsl_environment/./img/download_ubuntu.png" width=75%>
<p>インストールが完了すると、右下に以下の通知が表示されるので、起動を選択してください。
（スタートメニューからUbuntuを選択して実行しても大丈夫です。）</p>
<img src="wsl_environment/./img/ubuntu_up.png" width=75%>
<p>少し待つと、Ubuntuで使用するユーザーネームとパスワードの設定を求められるので入力してください。</p>
<p>ここで設定したパスワードの使用頻度はかなり多い（ソフトウェアのインストールなど、管理者レベルの操作で必要）ので、必ず覚えておく、またはメモとして取っておくようにしてください。</p>
<img src="wsl_environment/./img/setup_ubuntu.png" width=75%>
<p>コマンドが打ち込める状態になったら、WSL2の導入は終了です。これで、Windows10上でLinux（Ubuntu）を扱うことができるようになりました。</p>
<p>WSL2上でUbuntuを使うときはスタートメニューからUbuntuを選択して、実行することで、
使用することができます。（または、自分の好きなターミナルを設定して、WSL2を使用することもできます。）</p>
<img src="wsl_environment/./img/ubuntu_start.png" width=75%>
<div style="break-before: page; page-break-before: always;"></div><h1 id="processingをはじめよう"><a class="header" href="#processingをはじめよう">Processingをはじめよう</a></h1>
<h2 id="processingって何"><a class="header" href="#processingって何">Processingって何</a></h2>
<p>絵が描けるアプリケーションです．コードで絵を描きます．</p>
<p><img src="Processing/img/Pro.png" alt="icon" title="icon" /></p>
<h2 id="なんでprocessingなの"><a class="header" href="#なんでprocessingなの">なんでProcessingなの</a></h2>
<p>C言語をコマンドプロンプトの文字だけの真っ黒な画面でやるよりも楽しいしわかりやすいと思うからです．
そして，環境構築が楽だからです．</p>
<h2 id="processingをdlしよう"><a class="header" href="#processingをdlしよう">ProcessingをDLしよう</a></h2>
<p><a href="https://processing.org/download/">こちらのサイト</a>で環境を選べばDLが始まります．
DLしたファイルを開いて指示に従えばDL完了です．Processing.exeとかProcessing.appを実行すれば，もうさっそくプログラム作成ができます．</p>
<h2 id="qa"><a class="header" href="#qa">Q&amp;A</a></h2>
<p>Q:日本語が打てねぇぜ，あと文字小さい</p>
<ul>
<li>ファイル/設定/から日本語が使えるフォントと選びます．文字サイズもそこで変更できます．</li>
</ul>
<p>Q:簡単すぎてつまらん</p>
<ul>
<li>発展チャプターを用意してあります．</li>
</ul>
<p>Q:いやなんもわからん</p>
<ul>
<li>先輩かわかる同級生に聞いてみよう！</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="図形を描いてみよう"><a class="header" href="#図形を描いてみよう">図形を描いてみよう</a></h1>
<h2 id="今回の目標"><a class="header" href="#今回の目標">今回の目標</a></h2>
<p>円や長方形で構成された簡単な絵が描ける．</p>
<p>具体的には次の絵を描くことが目標です．
<img src="Processing/img/fig3-6.png" alt="画面" title="Processingの画面" /></p>
<h2 id="実際に図形を描く"><a class="header" href="#実際に図形を描く">実際に図形を描く</a></h2>
<h3 id="コードを書いてみよう"><a class="header" href="#コードを書いてみよう">コードを書いてみよう</a></h3>
<p>次のコードを入力してみましょう．最後のセミコロン(;)を忘れずに．</p>
<pre><code class="language-java">size(500,400);
</code></pre>
<p><img src="Processing/img/fig2-1.png" alt="画面" title="Processingの画面" /></p>
<h3 id="実行しよう"><a class="header" href="#実行しよう">実行しよう</a></h3>
<p>ウィンドウに再生マークのボタンがありますね．クリックすると実行されます．新しく画面(ウィンドウ)が表示されました．</p>
<p><img src="Processing/img/fig2-2.png" alt="画面" title="実行してでてきた画面" /></p>
<ul>
<li>実行ボタンを押してもウィンドウが表示されなかったらもう一度コードを確認してみよう．どこかが間違っているはず．</li>
</ul>
<h3 id="数字を変えてみよう"><a class="header" href="#数字を変えてみよう">数字を変えてみよう</a></h3>
<pre><code class="language-java">size(500,400);
</code></pre>
<p>の(500,400)と入力したところを別の数字にしてみましょう．</p>
<p>例えば</p>
<pre><code class="language-java">size(600,100);
</code></pre>
<p>と入力して，実行をすると</p>
<p><img src="Processing/img/fig2-3.png" alt="画面" title="実行してでてきた画面" /></p>
<p>横長になりました．</p>
<p>さて，お気づきの方もいるかもしれませんが，この<code>size(数字,数字);</code>というのは画面のサイズを指定しています．具体的には，<code>size(x,y);</code>というコードは画面の横の長さをx，縦の長さをyにする，という意味を持っています．</p>
<h3 id="コードを書いてみようその2"><a class="header" href="#コードを書いてみようその2">コードを書いてみようその2</a></h3>
<p>次のコードを入力してみましょう．入力し終わったら，実行ボタンを押して実行しましょう．</p>
<pre><code class="language-java">size(500,400);
rect(100,200,300,100);
</code></pre>
<p>次のような画面が表示されます．</p>
<p><img src="Processing/img/fig2-4.png" alt="画面" title="実行してでてきた画面" /></p>
<p>画面内に白い長方形が描かれました．数字をいろいろ変えて，この数が何を意味するのかを考えてみてください．</p>
<h3 id="rectの正体"><a class="header" href="#rectの正体">rectの正体</a></h3>
<p><code>rect(a,b,c,d)</code>を実行すると座標(a,b)を左上とする，横の長さc，縦の長さdの長方形が描かれます．</p>
<p><img src="Processing/img/fig2-5.svg" alt="画面" title="実行してでてきた画面" /></p>
<p>ここでの座標というのは数学でもでてきた平面での場所を表す数字です．上の図のように，画面の左上を原点としProcessingの世界では，xは右方向が正，yは下方向が正，と決まっています．y座標が下に行くほど増えていくところに注意です．</p>
<ul>
<li>Processingに対して「画面描いて！」とか「正方形描いて！」みたいに命令しているので，「命令」と呼びます．</li>
</ul>
<h3 id="練習"><a class="header" href="#練習">練習</a></h3>
<h4 id="演習2-1"><a class="header" href="#演習2-1">演習2-1</a></h4>
<blockquote>
<p>横600,縦300のウィンドウに，左上の座標が(100,50)で横の長さが200,縦の長さが100の長方形を描け．</p>
</blockquote>
<h4 id="演習2-2"><a class="header" href="#演習2-2">演習2-2</a></h4>
<blockquote>
<p>横450,縦600のウィンドウに，左上の座標が(100,100)で右下の座標が(400,400)の正方形を描け．</p>
</blockquote>
<h4 id="解答例"><a class="header" href="#解答例">解答例</a></h4>
<details><summary>解答例:コードを書いてから答えをみよう！</summary><div>
演習2-1
<pre><code class="language-java:演習2-1">size(600,300);
rect(100,50,200,100);
</code></pre>
<p>演習2-2：<code>rect(a,b,c,d)</code>のc,dは座標ではなく辺の長さです．辺の長さは400-100=300なので，cとdは300にする必要があります．</p>
<pre><code class="language-java:演習2-2">size(450,600);
rect(100,100,300,300);
</code></pre>
</div></details>
<h2 id="他の図形を描く"><a class="header" href="#他の図形を描く">他の図形を描く</a></h2>
<p>さきほどの<code>rect()</code>の他にも，三角形などを描く方法があります．
表にまとめてありますが，これらを頑張って覚える必要はありません．なぜなら，<a href="https://processing.org/reference/">リファレンス</a>をみればわかるからです．</p>
<table><thead><tr><th style="text-align: left">方法</th><th style="text-align: left">起こること</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>point(x,y)</code></td><td style="text-align: left">座標(x,y)に点をうつ</td></tr>
<tr><td style="text-align: left"><code>line(x1,y1,x2,y2)</code></td><td style="text-align: left">座標(x1,y1)と座標(x2,y2)が両端の線分を描く</td></tr>
<tr><td style="text-align: left"><code>ellipse(x,y,a,b)</code></td><td style="text-align: left">座標(x,y)を中心に横軸がa，縦軸がbの楕円を描く<sup class="footnote-reference"><a href="#1">1</a></sup></td></tr>
<tr><td style="text-align: left"><code>triangle(x1,y1,x2,y2,x3,y3)</code></td><td style="text-align: left">(x1,y1) と (x2,y2) と (x3,y3) をつなぐ三角形を描く</td></tr>
<tr><td style="text-align: left"><code>fill(r,g,b)</code></td><td style="text-align: left">この命令の後に描く図形の内部は色(r,g,b)<sup class="footnote-reference"><a href="#2">2</a></sup>で塗られる</td></tr>
<tr><td style="text-align: left"><code>stroke(r,g,b)</code></td><td style="text-align: left">この命令の後に描く図形の輪郭は色(r,g,b)で塗られる</td></tr>
</tbody></table>
<ul>
<li>上の表のxやaのことを引数(引数)と呼びます．</li>
</ul>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>aとbを同じ数cにすれば直径がcの円が描けます．例えばellipse(10,10,7,7)は中心(10,10)直径7の円を描きます．</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>色の指定方法については<a href="Processing/../ProcessingOther/color.html">補足資料</a>をご覧ください</p>
</div>
<p>fillの使い方を示します．</p>
<pre><code class="language-java">size(400,200);
ellipse(100,100,80,80);
fill(255,0,0);//ここから後に描く図形を赤く塗る
ellipse(300,100,80,80);
</code></pre>
<p><img src="Processing/img/fig2-6.png" alt="画面" title="実行してでてきた画面" /></p>
<p>ここで注意するのが，<em>プログラムは上から下へ順番に</em>実行されるということです．</p>
<p>プログラム中にある<code>//</code>ですが，コメントといい，<code>//</code>以降の文字列は改行があるまで無視されます．また，<code>/*</code>と<code>*/</code>で囲まれた文字列も無視されます．</p>
<pre><code class="language-java">size(400,300);
//コメント

/*
終点が明確である
コメント
*/

ellipse(x,y,200,200/*部分*/);

</code></pre>
<h2 id="練習-1"><a class="header" href="#練習-1">練習</a></h2>
<h3 id="演習2-3"><a class="header" href="#演習2-3">演習2-3</a></h3>
<blockquote>
<p>画像のように日本の国旗をかけ．アスペクト比などは厳密でなくて良い．※デフォルトの背景色は灰色で白くないので白くすること．
<img src="Processing/img/fig2-7.png" alt="画面" title="実行してでてきた画面" /></p>
</blockquote>
<h3 id="解答例-1"><a class="header" href="#解答例-1">解答例</a></h3>
<details><summary>解答例</summary><div>
演習2-3：正方形の真ん中の座標は(250,250)で，一辺が300なので，中心(250,250)直径300の円を描けば良い
<pre><code class="language-java:演習2-3">size(600,400);
fill(255,255,255);
rect(0,0,600,400);
fill(255,0,0);
ellipse(300,200,300,300);
</code></pre>
</div></details>
<h2 id="作る"><a class="header" href="#作る">作る</a></h2>
<p>数種類の図形でオリジナルの絵(思いつかなかったら信号)を書いてみましょう．</p>
<p>私は顔を書いてみました．</p>
<pre><code class="language-java">size(600,600);
ellipse(300,300,200,200);
fill(0,0,0);
ellipse(250,280,50,50);
ellipse(350,280,50,50);
line(250,350,350,350);
</code></pre>
<p>実行結果はこちらです．
<img src="Processing/img/fig3-6.png" alt="画面" title="Processingの画面" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="変数"><a class="header" href="#変数">変数</a></h1>
<h2 id="今回の目標-1"><a class="header" href="#今回の目標-1">今回の目標</a></h2>
<p>変数の使い方と，使う利点がわかる．</p>
<h2 id="定義と代入"><a class="header" href="#定義と代入">定義と代入</a></h2>
<h3 id="変数とは"><a class="header" href="#変数とは">変数とは</a></h3>
<p>別の言葉を使って例えるのならば箱です．何かを入れて保管(記憶)しておくことができます．</p>
<h3 id="変数の宣言"><a class="header" href="#変数の宣言">変数の宣言</a></h3>
<pre><code class="language-java">int a;
</code></pre>
<p>これでaという名前の変数が作られました．<code>int</code>は「整数を入れる変数を作れ」という意味です．
実行してでてきた小さいウィンドウ<sup class="footnote-reference"><a href="#1">1</a></sup>は無視しましょう．</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>size();関数で何も設定しなかったので最小サイズのウィンドウがでてきてしまいました．</p>
</div>
<h3 id="変数に数を入れる"><a class="header" href="#変数に数を入れる">変数に数を入れる</a></h3>
<p>このままだと，変数が空っぽなので数を入れます</p>
<pre><code class="language-java">int a;
a=6;
</code></pre>
<p><code>a=6</code>の行が追加されました．これでaという名前の変数に6という数字が入りました．注意するのは，ここでのイコール(=)は，<strong>等しいという意味ではありません</strong>．イコールの右にある数をaに「<strong>代入する</strong>」という意味です．
ところで，本当にaに6が入っているかどうか気になりますね．そこで，aという変数の中に何が入っているかを確認します．</p>
<pre><code class="language-java">int a;
a=6;
print(a);
</code></pre>
<p>下の黒いところがコンソールです．</p>
<p><code>print();</code>命令は，コンソールに表示させる命令です．</p>
<p><img src="Processing/img/fig3-1.png" alt="画面" title="Processingの画面" /></p>
<p>実行ボタンを押すとそこに6と表示されます．</p>
<p><img src="Processing/img/fig3-2.png" alt="画面" title="Processingの画面" /></p>
<p>地味ですね．別の数字も試して，結果がどうなるかを確認しましょう．また，次のコードのように定義と代入を同時に行うことができます．</p>
<pre><code class="language-java">int a=6;
print(a);
</code></pre>
<p>変数は別に一文字でなくてもよいです．</p>
<pre><code class="language-java">int apple=6;
int grape=4;
print(apple,grape);
</code></pre>
<p>このように変数に適切な名前を付けることで何を表しているのかを分かりやすくできます．</p>
<p>変数の命名ですが，</p>
<ul>
<li>アルファベット(大文字小文字問わない)かアンダーバーで始まる</li>
<li>一文字目以外はアルファベット，数字，アンダーバーのみで構成されている
ことがルールです．</li>
</ul>
<pre><code class="language-java">int w1000000007ushitapunikiakun;//よい
int _x;//よい
int 3_e;//エラー
</code></pre>
<h3 id="変数を使用するときのエラー"><a class="header" href="#変数を使用するときのエラー">変数を使用するときのエラー</a></h3>
<p>今度は値を代入せずに表示させます．</p>
<pre><code class="language-java">int a;
print(a);
</code></pre>
<p>実行すると</p>
<p><img src="Processing/img/fig3-3.png" alt="画面" title="Processingの画面" /></p>
<p>英語ができてました．エラー文といいます．これを読んで何がエラーの原因なのかを考えます．英語が読めなかったらGoogle先生に任せましょう．</p>
<p><img src="Processing/img/fig3-4.png" alt="画面" title="Processingの画面" /></p>
<p>原因はaに何も値を入れていないことです．「aという変数を作ったけれど，中身は空っぽなので表示できません！」という意味です．変数の中身を使う場合は中身を入れてあるかに注意しましょう．</p>
<p>また，<code>int a</code>でaという名前の変数を作らなかった場合もエラーになります．</p>
<pre><code class="language-java">a=28;
print(a);
</code></pre>
<p><img src="Processing/img/fig3-5.png" alt="画面" title="Processingの画面" /></p>
<p>他にも，同じ名前の変数は作れないルールがあります．<sup class="footnote-reference"><a href="#2">2</a></sup>．</p>
<pre><code class="language-java">int a;
int a;//変数名は被ってはいけない(エラー)
a=2;
</code></pre>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>厳密には，同じブロック内でなければ問題ありませんが，今は気にしなくてよいです．</p>
</div>
<h2 id="式で代入"><a class="header" href="#式で代入">式で代入</a></h2>
<pre><code class="language-java">int a;
a=1+3;
print(a);
</code></pre>
<p>このように式で代入することもできます．</p>
<table><thead><tr><th style="text-align: center">すること</th><th style="text-align: center">演算子</th><th style="text-align: center">例</th><th style="text-align: center">aの値</th></tr></thead><tbody>
<tr><td style="text-align: center">足し算</td><td style="text-align: center"><code>+</code></td><td style="text-align: center"><code>a=24+41</code></td><td style="text-align: center"><code>65</code></td></tr>
<tr><td style="text-align: center">引き算</td><td style="text-align: center"><code>-</code></td><td style="text-align: center"><code>a=5-12</code></td><td style="text-align: center"><code>-7</code></td></tr>
<tr><td style="text-align: center">掛け算</td><td style="text-align: center"><code>*</code></td><td style="text-align: center"><code>a=25*8</code></td><td style="text-align: center"><code>200</code></td></tr>
<tr><td style="text-align: center">割り算<sup class="footnote-reference"><a href="#3">3</a></sup></td><td style="text-align: center"><code>/</code></td><td style="text-align: center"><code>a=76/19</code></td><td style="text-align: center"><code>4</code></td></tr>
<tr><td style="text-align: center">割った余り<sup class="footnote-reference"><a href="#4">4</a></sup></td><td style="text-align: center"><code>%</code></td><td style="text-align: center"><code>a=25%4</code></td><td style="text-align: center"><code>1</code></td></tr>
</tbody></table>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>整数同士で割り算をすると，小数点以下は切り捨てられます．10/3=3,3/4=0となります．</p>
</div>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">4</sup>
<p>数学でいうと合同式のmodのようなものです．例えば，整数aの一の位はa%10で得ることができます．</p>
</div>
<p>変数を使って計算することも可能です．電卓みたいですね．</p>
<pre><code class="language-java">int grape=3;
int apple=5;
int fruit=grape+apple;
print(fruit);
</code></pre>
<pre><code class="language-java">int side=9;
int volume=side*side*side;
print(volume);
</code></pre>
<p>演算は括弧を使うことも可能です．</p>
<pre><code class="language-java">int a=5;
int b=3;
int c=(a+b)*(a-b);//8*2
print(c);//16
</code></pre>
<p>一行目ですが，</p>
<pre><code class="language-java">int a=5;
int b=3;
</code></pre>
<p>次のコードを確認しましょう．</p>
<pre><code class="language-java">int a=5;
a=a+6;
print(a);
</code></pre>
<p>このプログラムは少しトリッキーに見えるかもしれませんが，理路整然とシュミレーションしてみれば難しくありません．aという名前の変数にa+6の結果を代入するという意味ですが，このときのaは5ですので，aには5+6の11が代入されます．</p>
<p>プログラムは上から下へ順番に，書いてあること通りに実行されていきます．これは，当たり前のように感じますが，慣れていない頃は意外と忘れがちです．</p>
<p>また，セミコロンで区切ってさえあれば同じ行に命令を連ねることができますが，これは左から順番に実行されていきます．
次のソースコードでは，<code>a=b</code>と<code>b=a</code>が同じ行にあり，同時に実行するように見えるかもしれませんが，そんなことはありません．<code>a=b;</code>のあとに改行したコードと全く同じ意味になります．</p>
<pre><code class="language-java">int a=5;
int b=3;
a=b;b=a;
print(a,b);
</code></pre>
<pre><code class="language-java">int a=5;
int b=3;
a=b;
b=a;
print(a,b);
</code></pre>
<p>逆に，一行に詰め込むことも可能です．</p>
<pre><code class="language-java">int a=5;int b=3;a=b;b=a;print(a,b);
</code></pre>
<h3 id="演習3-1"><a class="header" href="#演習3-1">演習3-1</a></h3>
<blockquote>
<p>次のプログラムを実行して表示される数はいくつか．</p>
<pre><code class="language-java">int a=5;
int b=3;
a=a+b;
b=a-b;
print(b);
</code></pre>
</blockquote>
<h3 id="演習3-2"><a class="header" href="#演習3-2">演習3-2</a></h3>
<blockquote>
<p>二つの変数の値を入れ替えるにはどうすればよいか</p>
<pre><code class="language-java">int a=5;
int b=3;
//何らかの処理
print(a,b);//a=3,b=5を得たい
</code></pre>
</blockquote>
<h3 id="解答"><a class="header" href="#解答">解答</a></h3>
<details><summary>解答</summary><div>
演習3-1：5
上から順に実行されることに注意です．
<pre><code class="language-java">a=a+b;//a=5+3 aが8
b=a-b;//b=8-3 bが5
</code></pre>
<p>演習3-2：
別の変数を用意すると簡単に実現できます</p>
<pre><code class="language-java">int a=5;
int b=3;
int t;
t=a //tにaの値を取っておく
a=b; //aに上書きされても
b=t; //tにもともとのaの値が残っている
print(a,b);
</code></pre>
<p>また，裏技チックですが，変数を用意しない方法もあります</p>
<pre><code class="language-java">int a=5,b=3;

a = a + b;
b = a - b;
a = a - b;
println(a,b);

a = a * b;
b = a / b;
a = a / b;
println(a,b);

a = a ^ b;
b = a ^ b;
a = a ^ b;
println(a,b);
</code></pre>
<p>この書き方をしたコードを他人にみせたときに，</p>
</div></details>
<h2 id="変数の活用例"><a class="header" href="#変数の活用例">変数の活用例</a></h2>
<p>打つのが大変なのでコピペ推奨です．</p>
<pre><code class="language-java">size(600,600);
ellipse(300,300,200,200);
fill(0,0,0);
ellipse(250,280,50,50);
ellipse(350,280,50,50);
line(250,350,350,350);
</code></pre>
<p><img src="Processing/img/fig3-6.png" alt="画面" title="Processingの画面" /></p>
<p>チャプター2で出てきた顔です．
どうしてもこの顔が気に入らなければ別の絵を用意してもらって構いません．</p>
<p>この顔をもう少し右に表示させたくなったとします．そうなると，顔を作っている全ての関数のx座標の値を変えなければなりません．手間です．さらに変更したくなったらまたまたひとつずつ書き換えなければなりません．非常に面倒ですね．そこで，次のように変数を使います．</p>
<pre><code class="language-java">int x=300;
int y=300;
size(600,600);
ellipse(x,y,200,200);
fill(0,0,0);
ellipse(x-50,y-20,50,50);
ellipse(x+50,y-20,50,50);
line(x-50,y+50,x+50,y+50);
</code></pre>
<p>これで，一行目のxとyの初期値さえ変えれば，顔の位置を移動させることができるようになりました．このように，複数の場所に関与して来る数は変数にしておくと汎用性が高くなります．</p>
<h2 id="連ねて宣言"><a class="header" href="#連ねて宣言">連ねて宣言</a></h2>
<pre><code class="language-java">int a=3;
int b=5;
int c=2;
</code></pre>
<p>のように毎回<code>int</code>を書くのが面倒だという場合は</p>
<pre><code class="language-java">int a=3,b=5,c=2;
</code></pre>
<p>のようにコンマ(<code>,</code>)で区切って連ねることができます．</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="動きを作る"><a class="header" href="#動きを作る">動きを作る</a></h1>
<h2 id="目標"><a class="header" href="#目標">目標</a></h2>
<p>図形を動かすことができる</p>
<p><img src="Processing/img/fig4-1.gif" alt="画面" title="Processingの画面" /></p>
<h2 id="setupとdraw"><a class="header" href="#setupとdraw">setup()とdraw()</a></h2>
<pre><code class="language-java">//ここで変数の宣言をする

void setup(){
    //初めの設定：変数への代入，size()命令など
}

void draw(){
    //ここがずっと繰り返される
}
</code></pre>
<p>このようにプログラムを書くと，</p>
<ul>
<li>変数宣言がされる</li>
<li>setup()内が一度だけ呼び出される</li>
<li>draw()内が1秒間に60回<sup class="footnote-reference"><a href="#1">1</a></sup>繰り返される</li>
</ul>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>厳密には，frameRate()関数で設定した回数だけ処理されます．処理が追いつかないとは減る場合もあります．</p>
</div>
<p>例を次に示します．</p>
<pre><code class="language-java">int x=300,y=300;

void setup(){
    size(600,600);
}

void draw(){
    ellipse(x,y,100,100);
    x=x+1;
}
</code></pre>
<p>このプログラムは次のように動作します．</p>
<ul>
<li>x=300,y=300として変数が宣言</li>
<li>ウィンドウサイズを(600,600)に設定</li>
<li>その後，一秒間に60回，次を繰り返す
<ul>
<li>(x,y)が中心の円を書く</li>
<li>xを1増やす</li>
</ul>
</li>
</ul>
<p>draw()に円を描くプログラムと<code>x=x+1</code>が入っています．draw()の中は繰り返されるのでxの値がどんどん増えていきます．print(x)を後ろにおいてみるとよくわかります．
draw()は，1秒間に約60回実行されていますので，xは1秒で約60増えています．</p>
<p><img src="Processing/img/fig4-1.png" alt="画面" title="Processingの画面" /></p>
<p>さて，この実行結果ですが，xをずらしながら円を描いているので残像がついています．</p>
<p>そこで，draw()の初めで白い画面いっぱいの正方形で画面を塗りつぶして，一回まっさらの状態にします．</p>
<pre><code class="language-java">int x=300,y=300;

void setup(){
    size(600,600);
}

void draw(){
    fill(255,255,255);
    rect(0,0,600,600);
    fill(0,0,0);
    ellipse(x,y,100,100);
    x=x+1;
}
</code></pre>
<p>これで，残像がなくなりました．
<img src="Processing/img/fig4-1.gif" alt="画面" title="Processingの画面" /></p>
<h2 id="さらに動かす"><a class="header" href="#さらに動かす">さらに動かす</a></h2>
<p>前回使用した顔を描くプログラムについても同じことができます．</p>
<pre><code class="language-java">int x=300;
int y=300;

void setup(){
    size(600,600);
}

void draw(){
    fill(255,255,255);
    rect(0,0,600,600);//画面を真っ白に
    
    ellipse(x,y,200,200);
    fill(0,0,0);
    ellipse(x-50,y-20,50,50);
    ellipse(x+50,y-20,50,50);
    line(x-50,y+50,x+50,y+50);//顔を描く
    
    x=x+1;
}
</code></pre>
<p>左方向や斜め方向に移動させるにはどうすればよいでしょうか．また，等速直線運動ではなく等加速度運動にするにはどうすればようでしょうか．</p>
<p>次のプログラムでは，x方向とy方向のそれぞれの速度を変数として定義しています．</p>
<p><code>x=x+2;y=y+1;</code>のように直接書きたくもなりますが，これを変数として宣言しておくことで汎用性が高いプログラムになります．</p>
<pre><code class="language-java">int x=300,y=300;//座標
int vx=2,vy=1;//速度

void setup(){
    size(600,600);
}

void draw(){
    //中略
    
    x=x+vx;
    y=y+vy;
}
</code></pre>
<p>具体的には，次のプログラムのように加速度を導入したときに，これらの数を変数として宣言しておくと，初期値の設定がはじめの数行でまとめてできるので楽です．</p>
<pre><code class="language-java">int x=300,y=300;//座標
int vx=-10,vy=0;//速度
int ax=1,ay=0;//加速度

void setup(){
    size(600,600);
}

void draw(){
    //中略

    vx=vx+ax;
    vy=vy+ay;
    x=x+vx;
    y=y+vy;
}
</code></pre>
<p>ところで，ここまで作ってきたプログラムは顔が画面外に出てしまうともう戻ってきません．もし画面外に出たとき，戻ってくる，という処理が欲しいですよね？</p>
<p>それを実現するのが次のチャプターで出てくるif文です．</p>
<h2 id="おまけ"><a class="header" href="#おまけ">おまけ</a></h2>
<pre><code class="language-java">int x=300,y=300;

void setup(){
    size(600,600);
}

void draw(){
    fill(255,255,255);
    rect(0,0,600,600);//画面を真っ白に
    
    x=mouseX;
    y=mouseY;
    ellipse(x,y,200,200);
    fill(0,0,0);
    ellipse(x-50,y-20,50,50);
    ellipse(x+50,y-20,50,50);
    line(x-50,y+50,x+50,y+50);//顔を描く
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="分岐処理"><a class="header" href="#分岐処理">分岐処理</a></h1>
<h2 id="目標-1"><a class="header" href="#目標-1">目標</a></h2>
<p>次の動きをするプログラムを作成できる</p>
<p><img src="Processing/img/fig5-1.gif" alt="画面" title="Processingの画面" /></p>
<h2 id="いつ使うのか"><a class="header" href="#いつ使うのか">いつ使うのか</a></h2>
<p>ゲームとかでボタンを押すとキャラクターが動きますね．ボタンが押されたときと押されていないときで処理が違います．「もし〜ならこの処理をする」というのが欲しいですね．それがこれから紹介するif文です．</p>
<h2 id="もしだったら"><a class="header" href="#もしだったら">もし〜だったら</a></h2>
<p>「もしAだったらBをする」をプログラムにすると次のコードになります．</p>
<pre><code class="language-java">if(A){
    B
}
</code></pre>
<p>Bには命令が入り，Aには条件式が入ります．</p>
<table><thead><tr><th style="text-align: center">条件式</th><th style="text-align: center">日本語</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>a==b</code></td><td style="text-align: center">aとbが等しい</td></tr>
<tr><td style="text-align: center"><code>a&gt;b</code></td><td style="text-align: center">aがbより大きい</td></tr>
<tr><td style="text-align: center"><code>a&gt;=b</code></td><td style="text-align: center">aがb以上</td></tr>
<tr><td style="text-align: center"><code>a&lt;b</code></td><td style="text-align: center">aがbより小さい</td></tr>
<tr><td style="text-align: center"><code>a&lt;=b</code></td><td style="text-align: center">aがb以下</td></tr>
</tbody></table>
<p><strong>aとbが等しい時の条件式が=ではなく==であることに注意です．</strong></p>
<p>次のプログラムでaの値を変えたり条件式を変えたりして動作を確認しましょう．</p>
<pre><code class="language-java">int a=100;

if(a==100){ // もし、aが100なら
  println(&quot;aは100です&quot;);
}

if(a&gt;100){// aが100より大きいなら
  println(&quot;aは100より大きいです&quot;);
}
</code></pre>
<p>また，条件を連ねたいときは<code>&amp;&amp;</code>を使います．&quot;かつ&quot;と読み替えることができます．次のプログラムはaが100以上，かつaが200未満，という条件になります．</p>
<pre><code class="language-java">int a=100;

if( 100&lt;=a &amp;&amp; a&lt;200 ){ // aが100以上200未満なら
  println(&quot;aは100以上200未満です&quot;);
}
</code></pre>
<p>&quot;かつ&quot;(<code>&amp;&amp;</code>)に対して，<code>||</code><sup class="footnote-reference"><a href="#1">1</a></sup>は&quot;または&quot;を表す記号です．
次のプログラムはageが7である，またはageが5である，またはageが3であるときに&quot;七五三&quot;を表示するプログラムです．</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>見慣れない記号かもしれません，パイプラインと呼びます．キーボードの右上の方にあります．</p>
</div>
<pre><code class="language-java">int age=10000;

if(age==7 || age==5 || age==3){
    println(&quot;七五三&quot;);
}
</code></pre>
<h3 id="練習-2"><a class="header" href="#練習-2">練習</a></h3>
<h4 id="演習5-1"><a class="header" href="#演習5-1">演習5-1</a></h4>
<blockquote>
<p><code>int score=任意の整数;</code>に対して，scoreが60未満の場合に「留年」と表示するプログラムを作成しなさい．</p>
</blockquote>
<h4 id="演習5-2"><a class="header" href="#演習5-2">演習5-2</a></h4>
<blockquote>
<p>演習5-1に加えて，scoreが101以上の場合も&quot;留年&quot;と表示するプログラムを作成しなさい．</p>
</blockquote>
<h4 id="解答例-2"><a class="header" href="#解答例-2">解答例</a></h4>
<details><summary>解答例:コードを書いてから答えをみよう！</summary><div>
演習5-2:
<pre><code class="language-java">if(score&lt;60){
    println(&quot;留年&quot;);
}
</code></pre>
<p>演習5-3:</p>
<pre><code class="language-java">if(score&lt;60||score&gt;100){
    println(&quot;留年&quot;);
}
</code></pre>
</div></details>
<h2 id="elseelse-if"><a class="header" href="#elseelse-if">else,else if</a></h2>
<p>else（日本語: 他の）は文字通りそうでないときの処理を書きます．
次のif文では，<code>score&lt;60</code>の条件を満たさなかった場合，<code>else</code>の方が実行されます．</p>
<pre><code class="language-java">int score=74;
if(score&lt;60){
    println(&quot;不可&quot;);
}else{
    println(&quot;合格&quot;);
}
</code></pre>
<p>次の2つのプログラムと実行結果を比較してみましょう</p>
<pre><code class="language-java">int score=54;
if(score&lt;60){
    println(&quot;不可&quot;);
    println(&quot;課題を提出してもらったので点数を60点にしてあげます&quot;);
    score=60;
}else{
    println(&quot;合格&quot;);
}
</code></pre>
<pre><code class="language-java">int score=54;
if(score&lt;60){
    println(&quot;不可&quot;);
    println(&quot;課題を提出してもらったので点数を60点にしてあげます&quot;);
    score=60;
}
if(score&gt;=60){
    println(&quot;合格&quot;);
}
</code></pre>
<h2 id="実際に使う"><a class="header" href="#実際に使う">実際に使う</a></h2>
<p>前回のチャプターで作った顔が動くプログラムで，xが無限に増え続けるので画面外にいってしまいます．そこでif文を使うと，右端にいったら左端から出てくるようにすることができます．</p>
<pre><code class="language-java">int x=300;
int y=300;

void setup(){
    size(600,600);
}

void draw(){
    fill(255,255,255);
    rect(0,0,600,600);//画面を真っ白に

    ellipse(x,y,200,200);
    fill(0,0,0);
    ellipse(x-50,y-20,50,50);
    ellipse(x+50,y-20,50,50);
    line(x-50,y+50,x+50,y+50);//顔を描く

    x=x+3;
    if(x&gt;700){//もしxが700を超えたら
        x=-100;//xを-100に設定する
    }
}

</code></pre>
<p>y座標についても同じことをしてやると，古いDVDプレイヤーにスクリーンセーバーにありそうなちょっと面白い動きになります．</p>
<pre><code class="language-java">int x=300;
int y=300;
int vx=9,vy=6;

void setup(){
    size(600,600);
}

void draw(){
    fill(255,255,255);
    rect(0,0,600,600);//画面を真っ白に

    ellipse(x,y,200,200);
    fill(0,0,0);
    ellipse(x-50,y-20,50,50);
    ellipse(x+50,y-20,50,50);
    line(x-50,y+50,x+50,y+50);//顔を描く

    x=x+vx;
    y=y+vy;
    if(x&gt;700){//もしxが700を超えたら
        x=-100;//xを-100に設定する
    }
    if(y&gt;700){//もしyが700を超えたら
        y=-100;//yを-100に設定する
    }
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-6繰り返し処理"><a class="header" href="#chapter-6繰り返し処理">Chapter 6:繰り返し処理</a></h1>
<h2 id="前提知識"><a class="header" href="#前提知識">前提知識</a></h2>
<p><a href="Processing/../ProcessingOther/operator.html">補足資料/演算子</a></p>
<h2 id="まえおき"><a class="header" href="#まえおき">まえおき</a></h2>
<p>processingで次の画像のようなものを描くプログラムを作るにはどうすればよいでしょうか．
<img src="Processing/img/fig6-1.png" alt="画面" title="画面" /></p>
<p>ellipse命令を羅列して地獄になる予感がします．そこで，同じ処理や似たような処理を行うのがwhile文，for文です．</p>
<pre><code class="language-java">size(800,800);

ellipse(0,0,50,50);
ellipse(100,0,50,50);
ellipse(200,0,50,50);
ellipse(300,0,50,50);
ellipse(400,0,50,50);
//...大変
</code></pre>
<h2 id="while文"><a class="header" href="#while文">while文</a></h2>
<p>whileには「～の間」という意味があります．
プログラム上でも意味は同じで，「Aが正しい間，Bを繰り返し実行」する場合は</p>
<pre><code class="language-java">while(A){
    B
}
</code></pre>
<p>と書きます．Aにはif文でも使用した条件式が入ります．</p>
<table><thead><tr><th style="text-align: center">条件式</th><th style="text-align: center">日本語</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>a==b</code></td><td style="text-align: center">aとbが等しい</td></tr>
<tr><td style="text-align: center"><code>a&gt;b</code></td><td style="text-align: center">aがbより大きい</td></tr>
<tr><td style="text-align: center"><code>a&gt;=b</code></td><td style="text-align: center">aがb以上</td></tr>
<tr><td style="text-align: center"><code>a&lt;b</code></td><td style="text-align: center">aがbより小さい</td></tr>
<tr><td style="text-align: center"><code>a&lt;=b</code></td><td style="text-align: center">aがb以下</td></tr>
</tbody></table>
<p>プログラムを見てみましょう．</p>
<pre><code class="language-java">int hp=20;
int attack=6;
while(hp&gt;0){
    hp=hp-attack;
    print(hp);
}
print(&quot;GAME OVER&quot;);
</code></pre>
<p>動作の確認をするために，一個ずつ命令の通りにしたがってシュミレーションしてみましょう．</p>
<ul>
<li>hp=20,attack=6として変数が宣言</li>
<li>while文に入る
<ul>
<li>hp&gt;0であるため，中括弧<code>{}</code>内を実行する</li>
<li>hp=20-6=14となり，14が表示される</li>
<li>hp&gt;0であるため，中括弧内を実行する</li>
<li>hp=14-6=8となり，8が表示される</li>
<li>hp&gt;0であるため，中括弧内を実行する</li>
<li>hp=8-6=2となり，2が表示される</li>
<li>hp&gt;0であるため，中括弧内を実行する</li>
<li>hp=2-6=-4となり，-4が表示される</li>
<li>hp&gt;0を満たしていないため，while文を抜ける</li>
</ul>
</li>
<li><code>GAME OVER</code>と表示される</li>
</ul>
<p>注意するのは，<strong>まだ繰り返すか否かを判定する場所です</strong>．
上の例では，<code>p=hp-attack</code>の時点で<code>hp=-4</code>で<code>hp&gt;0</code>を満たしていませんが，その後の<code>print(hp)</code>は実行されています．これは，中括弧内の一連の処理を終えてから，まだループするかどうかの判定<code>hp&gt;0</code>を行っているからです．
while文を使えば，次のよう<sup class="footnote-reference"><a href="#1">1</a></sup>にすることで100回繰り返すことができます．</p>
<pre><code class="language-java">int i=1;
while(i&lt;=100){
    print(i);
    i++;
}
</code></pre>
<p>ここで，変数iは繰り返し回数を表していますが，繰り返し処理を行うたびにいちいち準備するのは大変です．
そこで，便利なのがfor文です．</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><code>i++</code>という書き方については<a href="Processing/../ProcessingOther/operator.html">補足資料/演算子</a>をご覧ください</p>
</div>
<p>##　for文</p>
<p>for文の書式は次の通りです．</p>
<pre><code class="language-java">for(変数の宣言;条件式;1回繰り返したあとに行う処理){
    //処理
}
</code></pre>
<pre><code class="language-java">for(int i=1;i&lt;=100;i++){
    print(i);
}
</code></pre>
<p>つまり，上のコードは，</p>
<ul>
<li>始めにi=0と宣言</li>
<li><code>i&lt;=100</code>を満たしている間，次を繰り返す
<ul>
<li><code>i</code>を表示する</li>
<li><code>i</code>を1増やす</li>
</ul>
</li>
</ul>
<p>while文と挙動が似ていますね．次のように書き換えることができます<sup class="footnote-reference"><a href="#2">2</a></sup>．</p>
<pre><code class="language-java">int i=1;
while(i&lt;=000){
  print(i);
  i++;
}
</code></pre>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>実は，変数<code>i</code>のスコープは異なります．詳しくは<a href="Processing/../ProcessingOther/var.html">補足資料/変数の詳しい話</a> をご覧ください</p>
</div>
<p>for文は，</p>
<ul>
<li>繰り返し用の変数の宣言</li>
<li>繰り返し用の変数への加算</li>
<li>繰り返しの条件
を同時に設定することができるます．</li>
</ul>
<p>使い分けですが，繰り返す回数が決まっている場合はすっきり書けるfor文，そうでない場合はwhile文を使うことが多いです．</p>
<p>次のように図形をたくさん連ねる処理を簡単にかけるのはfor，whileの強みです．</p>
<pre><code class="language-java">size(800,300);

for(int x=50;x&lt;800;x+=100){
  ellipse(x,150,100,100);
  //中心(x,150),半径100の円
}
</code></pre>
<p><img src="Processing/img/fig6-4.png" alt="画面" title="画面" /></p>
<h3 id="演習6-1"><a class="header" href="#演習6-1">演習6-1</a></h3>
<blockquote>
<p>1から100までの整数の和は5050ですが，これをfor文かwhile文を使ったプログラムによって計算しなさい．</p>
</blockquote>
<h3 id="演習6-2"><a class="header" href="#演習6-2">演習6-2</a></h3>
<blockquote>
<p>上の円を横に連なった絵を描くプログラムをwhile文を使って書きなさい．</p>
</blockquote>
<h3 id="解答-1"><a class="header" href="#解答-1">解答</a></h3>
<details><summary>解答</summary><div>
<p>演習6-1: 5050です．<code>100*(100+1)/2</code>と計算できます．</p>
<pre><code class="language-java">int sum=0;
for(int i=1;i&lt;100;i++)sum+=i;
print(sum);
</code></pre>
<p>繰り返す処理が1文の場合は
中括弧を省略することができます．</p>
<p>演習6-2:</p>
<pre><code class="language-java">size(800,300);

int x = 50;
while(x&lt;800){
  ellipse(x,150,100,100);
  x+=100;
}
</code></pre>
</div></details>
<h2 id="たくさんの図形を動かそう"><a class="header" href="#たくさんの図形を動かそう">たくさんの図形を動かそう</a></h2>
<p>次のようにたくさんの図形を描いて動かすことができます．</p>
<pre><code class="language-java">int x=0;

void setup(){
  size(800,300);
}

void draw(){
  fill(0);
  rect(0,0,800,300);
  fill(255);
  for(int dx=-50;dx&lt;=800;dx+=50){
    ellipse(x+dx, 150, 50, 50);
  }
  x++;
}
</code></pre>
<p><img src="Processing/img/fig6-6.gif" alt="画面" title="画面" /></p>
<p>draw()内の最後(<code>}</code>の前)に<code>if(x&gt;=50)x=0;</code>を追加してみましょう</p>
<p><img src="Processing/img/fig6-5.gif" alt="画面" title="画面" /></p>
<p>三角関数と組み合わせて，角度をfor文で回すことも可能です．</p>
<pre><code class="language-java">float r=0;

void setup(){
  size(600,600);
}

void draw(){
  fill(0);
  rect(0,0,600,600);
  fill(255);
  for(float a=0;a&lt;=2*PI*0.8;a+=0.5){
    ellipse(300+cos(a+r)*200,300+sin(a+r)*200,50,50);
  }
  r+=0.1;
  if(r&gt;2*PI)r-=2*PI;
}
</code></pre>
<p><img src="Processing/img/fig6-7.gif" alt="画面" title="画面" /></p>
<p>ここまで勉強したことだけでも，様々な表現ができそうですね．是非試してみてください．</p>
<h2 id="二重for文"><a class="header" href="#二重for文">二重for文</a></h2>
<p><img src="Processing/img/fig6-8.png" alt="画面" title="画面" /></p>
<p>各行に対して，for文で円を連ねています．</p>
<pre><code class="language-java">size(500,500);
for(int x=0;x&lt;=500;x+=100)ellipse(x,000,100,100);
for(int x=0;x&lt;=500;x+=100)ellipse(x,100,100,100);
for(int x=0;x&lt;=500;x+=100)ellipse(x,200,100,100);
for(int x=0;x&lt;=500;x+=100)ellipse(x,300,100,100);
for(int x=0;x&lt;=500;x+=100)ellipse(x,400,100,100);
for(int x=0;x&lt;=500;x+=100)ellipse(x,500,100,100);
</code></pre>
<p>上のfor文は</p>
<pre><code class="language-java">size(500,500);
for(int y=0;y&lt;=500;y+=100){
  for(int x=0;x&lt;=500;x+=100){
    ellipse(x,y,100,100);
  }
}
</code></pre>
<p>こうまとめられますね．</p>
<h3 id="演習6-3"><a class="header" href="#演習6-3">演習6-3</a></h3>
<blockquote>
<p>次の画像のようなマス目を書いてみましょう．
<img src="Processing/img/fig6-9.png" alt="画面" title="画面" /></p>
</blockquote>
<p>また，次の演習問題のようなこともできます．</p>
<h3 id="演習6-4"><a class="header" href="#演習6-4">演習6-4</a></h3>
<blockquote>
<p>次の画像のように階段状に円を描くにはどうすればよいでしょうか．
<img src="Processing/img/fig6-3.png" alt="画面" title="画面" /></p>
</blockquote>
<h3 id="解答-2"><a class="header" href="#解答-2">解答</a></h3>
<details><summary>解答</summary><div>
<p>一例です．</p>
<p>演習6-3:</p>
<pre><code class="language-java">size(500,500);

for(int x=0;x&lt;500;x+=50){
  for(int y=0;y&lt;500;y+=50){
    rect(x,y,49,49);
  }
}
</code></pre>
<p>line関数でも描くことができます．</p>
<p>演習6-4:</p>
<pre><code class="language-java">size(700,700);
for(int y=100;y&lt;=600;y+=100){
  for(int x=100;x&lt;=y;x+=100){
    ellipse(x,y,100,100);
  }
}
</code></pre>
</div></details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-7関数を作る"><a class="header" href="#chapter-7関数を作る">Chapter 7:関数を作る</a></h1>
<h2 id="前提知識-1"><a class="header" href="#前提知識-1">前提知識</a></h2>
<p><a href="Processing/../ProcessingOther/var.html">補足資料/変数の詳しい話</a></p>
<h2 id="関数とは"><a class="header" href="#関数とは">関数とは</a></h2>
<p>実は今まで使ってきた<code>rect()</code>や<code>fill()</code>，<code>print()</code>などは関数と呼ばれるものです．</p>
<p>例えば，</p>
<ul>
<li><code>rect(x,y,a,b)</code>で，座標<code>(x,y)</code>を左上の頂点として，横<code>a</code>縦<code>b</code>の長さである長方形が描かれます．</li>
<li><code>print(a)</code>では，変数<code>a</code>の内容が表示されます．</li>
<li><code>background(r,g,b)</code>では，背景色(r,g,b)で画面がクリアされます．</li>
</ul>
<p>このように，関数は0個以上の入力(<code>rect</code>の例だと<code>x,y,a,b</code>)に対して何かを行うものです．</p>
<p>そして，この関数は自分で作ることができます．</p>
<h2 id="引数"><a class="header" href="#引数">引数</a></h2>
<p><code>rect(x,y,a,b);</code>について，<code>x,y,a,b</code>をそれぞれ引数(ひきすう)と呼びます．
また，引数それぞれには型が決まっていて<code>rect</code>の場合は<code>float</code>型です</p>
<h2 id="関数を作る"><a class="header" href="#関数を作る">関数を作る</a></h2>
<p>関数を次のようにして定義できます．</p>
<pre><code class="language-java">void 関数名(型 仮引数名，型 仮引数名，......){
    //
}
</code></pre>
<p>例です．</p>
<pre><code class="language-java">void setup(){
    size(600,600);
}

void draw(){
    face(100,100);
    face(300,100);
}

void face(int x,int y){//座標(x,y)に顔を描く
    fill(255,255,255);
    ellipse(x,y,200,200);
    fill(0,0,0);
    ellipse(x-50,y-20,50,50);
    ellipse(x+50,y-20,50,50);
    line(x-50,y+50,x+50,y+50);
}
</code></pre>
<p>この例では<code>face(x,y)</code>という関数を作っています．</p>
<p><img src="Processing/img/voidfun.svg" alt="" /></p>
<p>引数は個数はいくつでもよいです．</p>
<pre><code class="language-java">int x=0,y=0;

void setup(){
    size(600,600);
}

void draw(){
    clearScreen();
    face(x,y);
    x=x+4;y=y+3;
    if(x&gt;700)x=-100;
    if(y&gt;700)y=-100;
}

void clearScreen(){//引数が0個の関数
    fill(255,255,255);
    rect(0,0,600,600);
}


void face(int x,int y){//座標(x,y)に顔を描く
    fill(255,255,255);
    ellipse(x,y,200,200);
    fill(0,0,0);
    ellipse(x-50,y-20,50,50);
    ellipse(x+50,y-20,50,50);
    line(x-50,y+50,x+50,y+50);
}

</code></pre>
<p><code>clearScreen()</code>という関数を作りました．引数が0個であり一見何の意味も成してないように見えますが，</p>
<pre><code class="language-java">fill(255,255,255);
rect(0,0,600,600);
</code></pre>
<p>が</p>
<pre><code class="language-java">clearScreen();
</code></pre>
<p>で，画面を真っ白にするという表現になったことで，何をしているかがわかりやすくなっています．
このように，関数の定義による一連の動作の抽象化はコードの可読性が増し，汎用性も高くなります．</p>
<h2 id="戻り値のある関数"><a class="header" href="#戻り値のある関数">戻り値のある関数</a></h2>
<p>戻り値がある関数は次のように書けます．</p>
<pre><code class="language-java">戻り値の型 関数名(型 仮引数名，型 仮引数名，......){
    return 戻り値;
}
</code></pre>
<p>使い方の例です．</p>
<pre><code class="language-java">/*(x1,y1)と(x2,y2)のユークリッド距離を求める*/
float distance(float x1,float y1,float x2,float y2){
    float dif_x=x1-x2;
    float dif_y=y1-y2;
    return sqrt(dif_x*dif_x+dif_y*dif_y);
}

void setup(){
    float a=distance(0,0,1.4,1.4);
    println(a);
}
</code></pre>
<p><img src="Processing/img/floatfun.svg" alt="" /></p>
<h3 id="演習7-1"><a class="header" href="#演習7-1">演習7-1</a></h3>
<blockquote>
<p>processingには，<code>background()</code>関数が用意されていて，色(r,g,b)で画面がクリアされる．
<code>background()</code>関数と同じ挙動をする<code>myBackground()</code>関数を作成せよ<sup class="footnote-reference"><a href="#1">1</a></sup>．</p>
</blockquote>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>ここでは，<code>background()</code>関数がProcessingに用意されていなかったとする．つまり，<code>myBackground()</code>関数内に<code>background()</code>を置く，ということではなく，<code>rect()</code>関数などで画面を塗りつぶす方法を使用する．</p>
</div>
<h3 id="演習7-2"><a class="header" href="#演習7-2">演習7-2</a></h3>
<blockquote>
<p><code>doubleCircle(x,y,r)</code>と実行したとき，中心の座標が<code>(x,y)</code>で，直径が<code>r</code>と<code>r/2</code>の円による二重丸が描画される関数を作成してみよ．</p>
</blockquote>
<p>実行例</p>
<pre><code class="language-java">void setup(){
  size(400,400);
}

void draw(){
  doubleCircle(100,100,100);
  doubleCircle(300,300,200);
}
</code></pre>
<p><img src="Processing/img/fig7-3.png" alt="" /></p>
<h3 id="演習7-3"><a class="header" href="#演習7-3">演習7-3</a></h3>
<blockquote>
<p>マウスポインタと円の衝突判定をする関数を作りたい．具体的には，次のプログラムを実行すると，円にマウスポインタが触れたら色が変更される，という動作をするように，<code>isInCircle</code>関数を作成せよ．
<img src="Processing/img/fig7-4.gif" alt="" /></p>
</blockquote>
<pre><code class="language-java">float ex=300;//円のx座標
float ey=300;//円のy座標
float r=100;//円の半径

void setup(){
  size(600,600);
}

void clearScreen(){//引数が0個の関数
    fill(255,255,255);
    rect(0,0,600,600);
}

/*
中心(cx,cy)半径rの円と点(ax,ay)の位置関係を返す
円の内部(境界線を含む)に点が入っている場合は1
円の外に点がある場合は0
が変える
*/
int isInCircle(float cx,float cy,float r,float ax,float ay){
    /*何かを書く*/
}

void draw(){
    clearScreen();//画面をまっさらに

    if(isInCircle(ex,ey,r,mouseX,mouseY)==1){
        fill(255,255,255);
        ellipse(ex,ey,r*2,r*2);
    }else{
        fill(0,255,255);
        ellipse(ex,ey,r*2,r*2);
    }

    ex+=5;//円を動かす
    if(ex&gt;=600+r){ //右端にいったら左端に戻す
        ex=-r;
    }
}
</code></pre>
<h3 id="解答-3"><a class="header" href="#解答-3">解答</a></h3>
<details><summary>解答</summary><div>
演習 7-1:
<p>画面の大きさがわからないため，十分に大きな長方形にしておく．</p>
<pre><code class="language-java">void myBackground(int r,int g,int b){
  fill(r,g,b);
  rect(-10,-10,3000,3000);
}
</code></pre>
<p>実は，システム変数を使えば必要以上に大きな長方形を描く必要がない．
また，<code>noStroke()</code>関数で図形の枠線をなくすことができる．</p>
<pre><code class="language-java">void myBackground(int r,int g,int b){
  fill(r,g,b);
  noStroke();//枠線なし
  rect(0,0,width,height);
}
</code></pre>
<p>演習 7-2:</p>
<pre><code class="language-java">void doubleCircle(float x,float y,float r){
  ellipse(x,y,r,r);
  ellipse(x,y,r/2,r/2);
}
</code></pre>
<p>演習 7-3:
円の内部に入っているということは，円の中心からの距離が，円の半径の長さ以下ということです．円の中心と，ある点の位置の距離は三平方の定理で求めることができます．</p>
<pre><code class="language-java">/*
中心(cx,cy)半径rの円と点(ax,ay)の位置関係を返す
円の内部(境界線を含む)に点が入っている場合は1
円の外に点がある場合は0
が変える
*/
int isInCircle(float cx,float cy,float r,float ax,float ay){
    float dx=(cx-ax);
    float dy=(cy-ay);
    if (sqrt(dx*dx+dy*dy)&gt;=r){
        return 1;
    }else{
        return 0;
    }
}
</code></pre>
</div></details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-8配列"><a class="header" href="#chapter-8配列">Chapter 8:配列</a></h1>
<h2 id="まとめて管理"><a class="header" href="#まとめて管理">まとめて管理</a></h2>
<p>シューティングゲームなどで，100個の弾の座標を管理したいときに次のように変数を定義していては大変です．</p>
<pre><code class="language-java">int x1= 4 ,y1=54;
int x2=15 ,y2= 4;
int x3=26 ,y3=34;
...
int x99=23,y99=2;
int x100=3,y100=4;
</code></pre>
<p>そこで配列です．宣言は次のようにできます．</p>
<pre><code class="language-java">int x[]=new int [100];
int y[]=new int [100];
型名 変数名[]=new 型名 [要素数];
</code></pre>
<p><code>new 型名[要素数]</code>を忘れないようにしましょう．</p>
<pre><code class="language-java">int a[]=new int [4];
a[0]=3;
a[1]=1;
a[2]=4;
a[3]=1;
print(a[2]);
</code></pre>
<p>これを図で表すと，
<code>変数名[インデックス]</code>で配列にアクセスができます．インデックスは0から(要素数-1)までの整数で指定します．</p>
<p>要素数が4の場合，a[0],a[1],a[2],a[3]の4つの要素が使える，という意味になります．a[4]は使えません(エラーになります)．
インデックスが0から始まることに注意です．</p>
<pre><code class="language-java">int a[]=new int [4];
a[0]=3;
a[1]=1;
a[2]=4;
a[3]=1;
for(int i=0;i&lt;4;i++){
    a[i]=a[i]+1;
    println(a[i]);
}
</code></pre>
<p>配列は一度に処理をするのに非常に便利です(上の例だとすべてに1を加算している．)
また，記録機能としても優秀です．</p>
<pre><code class="language-java">int a[]=new int [10];
int a[0]=1;
for(int i=1;i&lt;10;i++)a[i]=a[i-1]*2;
for(int i=0;i&lt;10;i++)println(a[i]);
</code></pre>
<h3 id="演習8-1"><a class="header" href="#演習8-1">演習8-1</a></h3>
<p>フィボナッチ数列の第20項目はいくつか．
ただし，フィボナッチ数列は，1,1,2,3,5,8,13,21,...のように初めの二項が1で，それ以降は前の二項の和となっている数列のことである．</p>
<h3 id="解答-4"><a class="header" href="#解答-4">解答</a></h3>
<details><summary>解答例:コードを書いてから答えをみよう！</summary><div>
<p>演習8-1:6765</p>
<pre><code class="language-java">int a[]=new int [30];
a[1]=1;a[2]=1;
for(int i=3;i&lt;=20;i++)a[i]=a[i-1]+a[i-2];
print(a[20]);
</code></pre>
</div></details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-9クラスとメンバ"><a class="header" href="#chapter-9クラスとメンバ">Chapter 9:クラスとメンバ</a></h1>
<h2 id="配列からクラスへ"><a class="header" href="#配列からクラスへ">配列からクラスへ</a></h2>
<p>配列は便利ですが，複数の情報を持つものが複数あると少しかさばります．具体的には座標，速度，加速度の3要素を持つ直線上の物体が10個あるときに，</p>
<pre><code class="language-java">int x[]=new int [10];//座標
int v[]=new int [10];//速度
int a[]=new int [10];//加速度
</code></pre>
<p>このようにコードをかくことができますが，少し冗長ですよね．というのも，x[i]とy[i]とa[i]は同じ物体についての情報であるのに別の配列に入っているという点で少し不便です．そこでそれらをまとめて扱う&quot;クラス&quot;というものを紹介します．</p>
<pre><code class="language-java">class object{
    double x;
    double v;
    double a;
}
</code></pre>
<p>これでobjectというデータの型が使えるようになります．</p>
<pre><code class="language-java">object ball;
ball=new object();
</code></pre>
<p>上のコードで，ballという名前のobject型の変数(のようなもの)が宣言されます．普通のint型などの変数とは違って<code>=new クラス名();</code>があることに注意です</p>
<p>参照と代入は次のように行えます．</p>
<pre><code class="language-java">ball.x=2.2;
ball.v=-3.2;
ball.a=0.1;
print(ball.x);
</code></pre>
<p>配列にする場合，少し手順が複雑になります．</p>
<pre><code class="language-java">object ball[]=new object[100];
for(int i=0;i&lt;100;i++)ball[i]=new object();

ball[0].x=2.2;
ball[0].v=-3.2;
ball[0].a=0.1;

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="game-1単発避けゲー"><a class="header" href="#game-1単発避けゲー">Game 1:単発避けゲー</a></h1>
<p>次のようなゲームを作ります．
マウスで水色の円を動かして，紫色の円から逃げるゲームです．
<img src="ProcessingGame/img/f1-4.gif" alt="" title=" " /></p>
<h2 id="基本"><a class="header" href="#基本">基本</a></h2>
<p>まず，マウスを追従する自機(円)を描きます．
背景色や大きさは適当に設定してください．</p>
<p><img src="ProcessingGame/img/f1-1.gif" alt="" title=" " /></p>
<pre><code class="language-java">void setup(){
  size(600,600);
}

void draw(){
  background(240,220,200);//背景
  ellipse(mouseX,mouseY,40,40);//自機
}
</code></pre>
<p>このプログラムでもいいのですが，後で衝突判定などを行いたいときに，自機の現在地や大きさが欲しくなるかもしれません．そこで，次のように書き直します．</p>
<pre><code class="language-java">void setup(){
  size(600,600);
}

void draw(){
  background(240,220,200);//背景
  int px=mouseX,py=mouseY,pr=20;
  ellipse(px,py,pr*2,pr*2);//自機
}
</code></pre>
<p>次に敵(円)を描きます．敵は，動かすことが前提なので，座標や半径を変数として取っておきます．
<img src="ProcessingGame/img/f1-2.png" alt="" title=" " /></p>
<pre><code class="language-java">int ex=300,ey=100,er=40;//敵の座標，半径

void setup(){
  size(600,600);
  gifset();
}

void draw(){
  background(240,220,200);//背景

  int px=mouseX,py=mouseY,pr=20;
  fill(20,200,200);
  ellipse(px,py,pr*2,pr*2);//自機
  
  fill(200,20,200);
  ellipse(ex,ey,er*2,er*2);//敵
  
  gifdraw();
}
</code></pre>
<p>さて，この状態では自機が敵に衝突しても何も起こりません．当たり判定を付けましょう．
2つの円の座標と半径がそれぞれ与えられたときに，円同士が重なっているかどうかを判定できれば良いです．</p>
<p>2つの円が重なっているときは，次のことが成り立ちます．</p>
<ul>
<li><code>2つの円の半径の和&gt;2つの円の中心同士の距離</code></li>
</ul>
<p>よって，これをif文で実装すれば良いです．</p>
<pre><code class="language-java">float distance = sqrt((px-ex)*(px-ex)+(py-ey)*(py-ey));//三平方の定理で，中心同士の距離を求める
if(distance &gt; pr+er){
//当たった判定
}
</code></pre>
<p>別の実装方法も考えられます．</p>
<pre><code class="language-java">int dx = px - ex;
int dy = py - ey;
int sr = pr + er;
if( dx*dx + dy*dy &lt; sr*sr ){
//当たった判定
}
</code></pre>
<p>肝心の，当たったときの処理ですが，とりあえず<code>stop();</code>関数を入れておきましょう．<code>stop()</code>関数はウィンドウの状態を維持したまま<code>draw()</code>関数の実行が止まります．</p>
<h2 id="文字の描画"><a class="header" href="#文字の描画">文字の描画</a></h2>
<p>このままでは，敵に当たると急に動かなくなるので，ユーザーは困惑するでしょう．「GAMEOVER」の文字くらいは欲しいですね．</p>
<p>Processingには，文字を描画する関数が用意されています．</p>
<pre><code class="language-java">textAlign(LEFT,TOP);
textSize(128);
text(&quot;GAMEOVER&quot;, 00, 00);
</code></pre>
<p><code>text(S,x,y)</code>は文字列<code>S</code>を<code>(x,y)</code>を基準に描く関数です．
<code>textSize()</code>関数と<code>textAlign()</code>関数は<code>text()</code>関数で描かれる文字の大きさや基準点を指定しています．
詳しく知りたい人は調べてみてください．</p>
<p>文字の色は<code>fill()</code>で設定できます．
<img src="ProcessingGame/img/f1-3.gif" alt="" title=" " /></p>
<h2 id="敵を動かす"><a class="header" href="#敵を動かす">敵を動かす</a></h2>
<p>敵を動かせば一応ゲームとして遊べるようになります．
敵の座標は<code>ex,ey</code>の変数で管理しているので，これを変えてやれば良いです．</p>
<p>敵の動かし方ですが，
<a href="ProcessingGame/../Processing/chapter_03.html">プログラミング入門/動きを作ろう</a>
<a href="ProcessingGame/../Processing/chapter_04.html">プログラミング入門/分岐処理</a>
を参考にして作ってみてください．</p>
<h2 id="最終的なプログラム一例"><a class="header" href="#最終的なプログラム一例">最終的なプログラム(一例)</a></h2>
<details><summary>プログラム</summary><div>
<pre><code class="language-java">int ex=300,ey=100,er=100;
int vx=20,vy=10;

void setup(){
  size(600,600);
}

void draw(){
  background(240,220,200);//背景


  int px=mouseX,py=mouseY,pr=20;
  fill(20,200,200);
  ellipse(px,py,pr*2,pr*2);//自機
  
  fill(200,20,200);
  ellipse(ex,ey,er*2,er*2);//敵
  
  int dx = px - ex;
  int dy = py - ey;
  int sr = pr + er;
  if( dx*dx + dy*dy &lt; sr*sr ){
    textAlign(LEFT,TOP);
    textSize(128);
    fill(255,0,0);
    text(&quot;GAMEOVER&quot;, 00, 00);
    stop();
  }
  ex+=vx;
  ey+=vy;
  if(ex&gt;=600||ex&lt;0){
    vx=-vx;
  }
  if(ey&gt;=600||ey&lt;0){
    vy=-vy;
  }
  
}
</code></pre>
</div></details>
<h2 id="さらにゲームらしく"><a class="header" href="#さらにゲームらしく">さらにゲームらしく</a></h2>
<p>このゲームに付け加える要素として次のようなものが考えられます．</p>
<ul>
<li>避けた続けた時間をスコアとしてゲームオーバー時に表示させる</li>
<li>敵のスピードがだんだん早くなるようにする</li>
<li>ゲームオーバーになったあとにリトライできるようにする</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="game-2鳥のゲーム"><a class="header" href="#game-2鳥のゲーム">Game 2:鳥のゲーム</a></h1>
<p>今回は，キーボードを押すとキャラクターが上昇するゲームを作成します．</p>
<p>工事中</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="発展平方根"><a class="header" href="#発展平方根">発展:平方根</a></h1>
<p>平方根は<code>sqrt</code>関数を使えば得られます．</p>
<pre><code class="language-java">float a=sqrt(2);
print(a);
</code></pre>
<p>そもそも，どのようにして<code>sqrt</code>関数内で平方根を計算しているのでしょうか．もし<code>sqrt</code>関数が使えなかったらどうすればよいでしょうか．</p>
<p>例えば，次のように実装してみたとしましょう．</p>
<pre><code class="language-java">float fun(float a){
    float ans=0;
    while(true){
        ans+=0.001f;
        if(ans*ans==a)break;
    }
    return ans;
}
</code></pre>
<p>このプログラムには問題点があり，</p>
<ul>
<li>aが大きな値(例えば40000，試してみてください)だと時間がかかる</li>
<li>平方根はだいたい無理数なのでans*ans==aになることはほとんどない→永久にwhile文を抜けださない
といった点で困ります．後者は<code>ans*ans</code>と<code>a</code>の差が十分に小さかったら，という処理で回避できるかもしれませんが前者はどうにもなりません．
実際のsqrt関数は，ある程度の桁数の精度を得ることができるので，どうやらこの方法ではないようです．</li>
</ul>
<h2 id="二分探索"><a class="header" href="#二分探索">二分探索</a></h2>
<pre><code class="language-java">float fun(float a){
    float l=0;
    float r=a;
    while(true){
        float m=(l+r)/2;
        if(m*m&gt;a)r=m;
        else l=m;

        float d=m*m-a;
        if(d&lt;0)d=-d;
        if(d&lt;0.00000001f)break;
    }
    return (l+r)/2;
}
</code></pre>
<p>例えば，100の平方根を求めるときに50の</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="再帰でフラクタル図形"><a class="header" href="#再帰でフラクタル図形">再帰でフラクタル図形</a></h1>
<p>フラクタル図形(構造)とは，その図形自身の一部が自身の相似な図形となっている図形や構造のことです．</p>
<pre><code class="language-java">
void rerect(int x,int y,int side,int cnt){
  if(cnt&lt;=0)return;
  rect(x,y,side,side);
  side/=3;
  for(int dx=0;dx&lt;=1;dx++){
    for(int dy=0;dy&lt;=1;dy++){
      rerect(x+dx*side,y+dy*side,side,cnt-1);
    }
  }
}

void setup(){
  size(800,800);
  frameRate(10);
}

void draw(){
  background(0,0,0);
  stroke(255);
  noFill();
  rerect(100,100,600,7);
}

</code></pre>
<pre><code class="language-java">int cnt=0;
float t=0;

void setup(){
  size(1100,800);
  frameRate(30);
}

void tree(float x,float y,float s,float r,int c){
  if(c&lt;=0)return;
  for(int i=-2;i&lt;=2;i+=2){
    float nr=i*0.15+r;
    float dx=cos(nr)*s;
    float dy=sin(nr)*s;
    line(x,y,x+dx,y+dy);
    tree(x+dx,y+dy,s*0.9,nr,c-1);
  }
}

void draw(){
  background(0);
  strokeWeight(2);
  stroke(255);
  tree(width/2,height,150,-PI/2,6);
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="三角関数"><a class="header" href="#三角関数">三角関数</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="コンピュータ上での色の表現"><a class="header" href="#コンピュータ上での色の表現">コンピュータ上での色の表現</a></h1>
<h2 id="色の指定"><a class="header" href="#色の指定">色の指定</a></h2>
<p>Processingではfill命令やstroke命令で描画する色をしてすることができます．(r,g,b)はred,green,blueの光の三原色の混じり具合を表しています．それぞれ0~255の整数値で設定できます．</p>
<p>絵具とは違い，光であるので色が混じると白色に近くなっていきます．次の表に示します．</p>
<table><thead><tr><th style="text-align: left">(r,g,b)</th><th style="text-align: left">色</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>(000,000,000)</code></td><td style="text-align: left">黒</td></tr>
<tr><td style="text-align: left"><code>(255,255,255)</code></td><td style="text-align: left">白</td></tr>
<tr><td style="text-align: left"><code>(255,000,000)</code></td><td style="text-align: left">赤</td></tr>
<tr><td style="text-align: left"><code>(000,255,000)</code></td><td style="text-align: left">緑</td></tr>
<tr><td style="text-align: left"><code>(000,000,255)</code></td><td style="text-align: left">青</td></tr>
<tr><td style="text-align: left"><code>(255,255,000)</code></td><td style="text-align: left">黄</td></tr>
<tr><td style="text-align: left"><code>(255,000,255)</code></td><td style="text-align: left">紫</td></tr>
<tr><td style="text-align: left"><code>(000,255,255)</code></td><td style="text-align: left">水</td></tr>
</tbody></table>
<p>デザインの話になりますが，上の表にあるような極端に振った(255とか0)値を含んだ色を使うと，主張が激しく感じます(個人差はありますが)．意図的にそうしたい場合を除いて，実際に色を使う場合は，そのような色を避けて優しい色遣いをするとよいです．</p>
<p>また，上の表は覚える必要はなく，Processingのツールタブから色選択...を選択すると下の画像のようなウィンドウが出てきます．</p>
<p><img src="ProcessingOther/img/figc-1.png" alt="color" title="color" /></p>
<p>これを使えば使いたい色のrgb値がわかります．</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="変数の詳しい話"><a class="header" href="#変数の詳しい話">変数の詳しい話</a></h1>
<h2 id="整数型浮動小数点型"><a class="header" href="#整数型浮動小数点型">整数型，浮動小数点型</a></h2>
<p>chapter2では<code>int</code>で整数をいれる変数を作れることがわかりました．これによって作られた変数をint型変数，といいます．あるいは，整数が入るので単に整数型とも言います．</p>
<pre><code class="language-java">float a=1.5;
float b=1.5;
print(a*b);//2.25
</code></pre>
<p>上のサンプルのように，<code>int</code>の代わりに<code>float</code>を使うと小数を代入することができます．</p>
<pre><code class="language-java">int a=5;
int b=3;
println(a/b);//1
println(float(a)/b);//1.66666...
</code></pre>
<p>整数型同士の割り算は小数点以下を切り捨てられてしまうので，小数の値を得たい場合は，割り算をする前にfloat(a)でfloat型に変換し，切り捨てを行わないようにします．</p>
<p>さらに精度を良くして数を扱う場合は整数ならlong型，小数ならdouble型を使います．</p>
<table><thead><tr><th style="text-align: left">型名</th><th style="text-align: left">代入できる値</th></tr></thead><tbody>
<tr><td style="text-align: left">int</td><td style="text-align: left">-2147483648から2147483647の整数</td></tr>
<tr><td style="text-align: left">long</td><td style="text-align: left">-9223372036854775808から9223372036854775807の整数</td></tr>
<tr><td style="text-align: left">float</td><td style="text-align: left">小数</td></tr>
<tr><td style="text-align: left">double</td><td style="text-align: left">float型よりも精度のよい小数</td></tr>
</tbody></table>
<p>long型に値を代入する場合，末尾にLをつけないとエラーになることがあります．</p>
<pre><code class="language-java">long a=9223372036854775807L;//Lをつける
</code></pre>
<h2 id="変数のスコープ"><a class="header" href="#変数のスコープ">変数のスコープ</a></h2>
<p>例えば，<code>apple_cost</code>を<code>void draw()</code>中で使いたいときに次のようなコードを書いたとします．これはエラーになります．
なぜでしょうか．</p>
<pre><code class="language-java">void setup(){
    int apple_cost=80;
    size(600,600);
}

void draw(){
    printf(apple_cost);
}
</code></pre>
<p>原因は変数のスコープです．スコープは範囲という意味です．実は，<code>void setup()</code>内で宣言された<code>apple_cost</code>という変数は，<code>void setup()</code>内でしか使用することができません．</p>
<p>あるブロック内で宣言された変数はそのブロック内でしか使用できません．
ブロックとは，中括弧<code>{</code>と<code>}</code>で囲まれた区間のことです．</p>
<p><code>{</code>と<code>}</code>はfor文やif文などでも使われているので，これもブロックになります．</p>
<pre><code class="language-java">void setup(){
    size(600,600);
}

void draw(){
    for(int i=0;i&lt;10;++i){
        int foo=31;//このfor文内でしか使用できない
    }

    int hoge=3;
    if(hoge==3){
        int piyo;//このif文内でしか使用できない
    }
}
</code></pre>
<p>ブロックの垣根を超えて変数を使用する場合は，ブロックの外で変数の宣言をします．
特に，どのブロックにも属していない変数のことをグローバル変数といいます．</p>
<pre><code class="language-java">int apple_cost=80;//グローバル変数

void setup(){
    size(600,600);
}

void draw(){
    printf(apple_cost);
}
</code></pre>
<p>また，同じブロックに属していなければ，区別が可能であるので変数の名前が被っていても問題ありません．</p>
<pre><code class="language-java">int sum(int v1,int v2){
    int ans=v1+v2;
    return ans;
}

int mul(int v1,int v2){
    int ans=v1*v2;
    return ans;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="演算子"><a class="header" href="#演算子">演算子</a></h1>
<h2 id="省略"><a class="header" href="#省略">省略</a></h2>
<pre><code class="language-java">int apple=0;
apple=apple+2;
apple=apple-3;
apple=apple*5;
apple=apple/7;
apple=apple%11;
</code></pre>
<p>上の式のように自分自身に対する計算は，短く書くことができます．</p>
<pre><code class="language-java">int apple=0;
apple+=2;
apple-=3;
apple*=5;
apple/=7;
apple%=11;
</code></pre>
<p>また，1を足すまたは引く場合はさらに短く書くことができます．</p>
<pre><code class="language-java">int apple=0;
apple++;//apple=apple+1と同じ
apple--;//apple=apple-1と同じ
</code></pre>
<p>++を先に書くこともできます．これらは挙動が違います．</p>
<pre><code class="language-java">int a=0;
print(a++);
print(a);
a=0;
print(++a);
print(a);
</code></pre>
<h2 id="bit演算子"><a class="header" href="#bit演算子">bit演算子</a></h2>
<p>bitにかかわる演算子です．</p>
<table><thead><tr><th style="text-align: center">すること</th><th style="text-align: center">演算子</th><th style="text-align: center">例</th><th style="text-align: center">aの値</th></tr></thead><tbody>
<tr><td style="text-align: center">AND</td><td style="text-align: center"><code>&amp;</code></td><td style="text-align: center"><code>a=1&amp;3</code></td><td style="text-align: center"><code>1</code></td></tr>
<tr><td style="text-align: center">OR</td><td style="text-align: center">`</td><td style="text-align: center">`</td><td style="text-align: center">`a=1</td></tr>
<tr><td style="text-align: center">XOR</td><td style="text-align: center"><code>^</code></td><td style="text-align: center"><code>a=1^3</code></td><td style="text-align: center"><code>2</code></td></tr>
<tr><td style="text-align: center">左にビットシフト</td><td style="text-align: center"><code>&lt;&lt;</code></td><td style="text-align: center"><code>a=1&lt;&lt;3</code></td><td style="text-align: center"><code>8</code></td></tr>
<tr><td style="text-align: center">右にビットシフト</td><td style="text-align: center"><code>&gt;&gt;</code></td><td style="text-align: center"><code>a=4&gt;&gt;1</code></td><td style="text-align: center"><code>2</code></td></tr>
</tbody></table>
<p>例えば，変数aの2ビット目(一番右を0ビット目とする)が1立っているかどうか(1であるか)を確かめるには，</p>
<pre><code class="language-java">if((a&amp;(1&lt;&lt;2))!=0)print(&quot;aの2ビット目は立っています&quot;);
</code></pre>
<p>で調べることができます．</p>
<p>応用すると，部分集合が全列挙できます．</p>
<pre><code class="language-java">int a[]={0,1,2,3,4};
int size=5;

for(int i=0;i&lt;(1&lt;&lt;size);i++){
  for(int k=0;k&lt;size;k++){
    if((i&amp;(1&lt;&lt;k))!=0){
      print(a[k]);
    }
  }
  print(&quot;\n&quot;);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scratchの命令に置き換えると"><a class="header" href="#scratchの命令に置き換えると">Scratchの命令に置き換えると？</a></h1>
<table><thead><tr><th style="text-align: left">ブロック</th><th style="text-align: left">Processing</th></tr></thead><tbody>
<tr><td style="text-align: left"><img src="ProcessingOther/img/if.png" alt="a" title="a" /></td><td style="text-align: left"><code>if(a&gt;50){}</code></td></tr>
<tr><td style="text-align: left"><img src="ProcessingOther/img/for.png" alt="a" title="a" /></td><td style="text-align: left"><code>for(int i=0;i&lt;10;i++){}</code></td></tr>
<tr><td style="text-align: left"><img src="ProcessingOther/img/and.png" alt="a" title="a" /></td><td style="text-align: left"><code>50&lt;a &amp;&amp; a&lt;100</code></td></tr>
<tr><td style="text-align: left"><img src="ProcessingOther/img/else.png" alt="a" title="a" /></td><td style="text-align: left"><code>if(a==50){}else{}</code></td></tr>
<tr><td style="text-align: left"><img src="ProcessingOther/img/while.png" alt="a" title="a" /></td><td style="text-align: left"><code>a=0;while(!a==50){a=a+1;}</code></td></tr>
<tr><td style="text-align: left"><img src="ProcessingOther/img/def.png" alt="a" title="a" /></td><td style="text-align: left"><code>void greeting(string name){print(name);}</code></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="processingの次は"><a class="header" href="#processingの次は">Processingの次は？</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="サンプルプログラム"><a class="header" href="#サンプルプログラム">サンプルプログラム</a></h1>
<p>全てShibaken28によって書かれました．一部コードの可読性が著しく低いものがあります．</p>
<h2 id="時計"><a class="header" href="#時計">時計</a></h2>
<p><img src="ProcessingSample/img/clock.gif" alt="画面" title="画面" /></p>
<details><summary>ソースコード</summary><div>
<pre><code class="language-java">void setup(){
  size(600,600);
}

void draw(){
  fill(0);
  rect(0,0,width,height);
  int hy=height/24;
  int my=height/60;
  int sy=height/60;
  stroke(170);
  fill(255);//白色
  for(int i=1;i&lt;=hour();i++)rect(0,600-hy*i,200,hy);
  for(int i=1;i&lt;=minute();i++)rect(200,600-my*i,200,my);
  for(int i=1;i&lt;=second();i++)rect(400,600-sy*i,200,sy);
}
</code></pre>
</div></details>
<h2 id="歪み"><a class="header" href="#歪み">歪み</a></h2>
<p><img src="ProcessingSample/img/y.gif" alt="画面" title="画面" /></p>
<details><summary>ソースコード</summary><div>
<pre><code class="language-java">int r=40;
void setup(){fullScreen();}
void draw(){
  clear();noStroke();
  float X=mouseX,Y=mouseY;
  for(int x=0;x&lt;=width;x+=r){
    for(int y=0;y&lt;=height;y+=r){
      float tx=x,ty=y,d=PI/2;
      float dx=X-x,dy=Y-y;
      float l=sqrt(dx*dx+dy*dy);
      if(X-x!=0)d=atan(dy/dx);
      else if(Y&gt;y)d=-d;
      if(X-x&gt;0)d=d-PI;
      
      tx+=cos(d)*r*log(l);ty+=sin(d)*r*log(l);
      circle(tx,ty,r);
    }
  }
}
</code></pre>
</div></details>
<h2 id="波"><a class="header" href="#波">波</a></h2>
<p><img src="ProcessingSample/img/wave.gif" alt="画面" title="画面" /></p>
<details><summary>ソースコード</summary><div>
<pre><code class="language-java">int w=100;
float wave[]=new float[w];
float y=400;
float t=0;
float x;

void setup(){
  fullScreen();
  x=displayWidth;
}

void draw(){
  float ww=x/w;
  background(0);
  strokeWeight(ww-1);
  stroke(0,255,255);
  for(int i=0;i&lt;w;i++){
    wave[i]=0;
    float T=120,la=630;
    float A=25;
    wave[i]+=A*sin(2*PI*(t/T-i*ww/la));
    T=70;la=450;
    A=30;
    wave[i]+=A*sin(2*PI*(t/T-i*ww/la));
    T=-200;la=1050;
    A=20;
    wave[i]+=A*sin(2*PI*(t/T-i*ww/la));
    line(i*ww,wave[i]+y,i*ww,displayHeight);
  }
  t++;
}
</code></pre>
</div></details>
<h2 id="波動"><a class="header" href="#波動">波動</a></h2>
<p><img src="ProcessingSample/img/circle.gif" alt="画面" title="画面" /></p>
<details><summary>ソースコード</summary><div>
<pre><code class="language-java">int r=30;
int X, Y, R;
void setup() {
  fullScreen();
}
void draw() {
  background(0);
  fill(255);
  noStroke();
  R+=10;
  if (mousePressed) {
    X=mouseX;
    Y=mouseY;
    R=0;
  }
  for (int x=0; x&lt;2000; x+=r) {
    for (int y=x%7; y&lt;1500; y+=r) {
      float d=dist(x, y, X, Y);
      circle(x, y, r-(R&lt;d+500&amp;&amp;d&lt;R?(-R+d)/10+50:0));
    }
  }
}
</code></pre>
</div></details>
<h2 id="弾幕避け"><a class="header" href="#弾幕避け">弾幕避け</a></h2>
<p><img src="ProcessingSample/img/danmaku.gif" alt="画面" title="画面" /></p>
<details><summary>ソースコード</summary><div>
<pre><code class="language-java">class Point{
  float x;
  float y;
  float d;
  float s;
  float far;
  float r;
  int t_f=1;
  color col;
  Point(float p,float q,float t,float v,float h,color c)
  {
    x=p;
    y=q;
    d=t;
    s=v;
    r=h;
    col=c;
  }
  
  void go(float p,float q,float t,float v,float h)
  {
    x=p;
    y=q;
    d=t;
    s=v;
    r=h;
  }
  
  void move()
  {
    if(s!=0){
      x=x+cos(radians(d))*s;
      y=y+sin(radians(d))*s;
    }
  }
  
  void hit()
 {
   if(time&gt;10)
   {
     far=sqrt((mouseX-x)*(mouseX-x)+(mouseY-y)*(mouseY-y));
     if(far&lt;5){t_f=0;}else{t_f=1;}
   }
 }
 
 void away()
 {
   if(x&gt;width){d=180-d;}
   else if(x&lt;0){d=180-d;}
   else if(y&gt;height){d=-d;}
   else if(y&lt;0){d=-d;}
 }
  
}

Point[] zahyo=new Point[512];
int use_n=0;
int rad=0;
int level=1;
float time=0; 
float speed=3;
int hankei=10;
int ran=0;

void setup()
{
  size(512,512);
  background(200);
  noStroke();
  for(int i=0; i&lt;zahyo.length ;i++)
  {
    zahyo[i]=new Point(-64,-64,0,0,-1,color(i,random(255),255));
  }
  run();
}

void draw()
{
  fill(255,255,255);
  rect(0,0,width,height);
  fill(0,0,0);
  for(int i=0; i&lt;zahyo.length ;i++)
  {
    fill(zahyo[i].col);
    zahyo[i].move();
    zahyo[i].away();
    ellipse(zahyo[i].x,zahyo[i].y,zahyo[i].r,zahyo[i].r);
  }
  fill(0,255,0);
  ellipse(width/2,height/2,40,40);
  fill(255,0,0);
  ellipse(mouseX,mouseY,10,10);
  for(int i=0; i&lt;zahyo.length ;i++)
  {
    zahyo[i].hit();
    if(zahyo[i].t_f==0)
    {
      noLoop();
      textSize(64);
      text(&quot;GAME OVER&quot;, 0, 300);
    }
  }
  time += 1;
  textSize(32);
  text(&quot;balls:&quot;+level, 00, 32);
  if (time/(20-level/15)==int(time/(20-level/15)))
  {
    level+=1;
    run();
  }
}

void incuse()
{
  zahyo[use_n].go(width/2,height/2,rad,speed,hankei);
  use_n += 1;
  if (use_n&gt;=zahyo.length){use_n=0;}
}

void run()
{
  speed=1.5;
  hankei=10+int(random(0,10));
  rad+=7;
  zahyo[use_n].go(width/2,height/2,rad,speed,hankei);
  incuse();
}
</code></pre>
</div></details>
<h2 id="カージオイド"><a class="header" href="#カージオイド">カージオイド</a></h2>
<p><img src="ProcessingSample/img/card.gif" alt="画面" title="画面" /></p>
<details><summary>ソースコード</summary><div>
<pre><code class="language-java">float t=0,x,y;
void setup(){fullScreen();x=displayWidth/2;y=displayHeight/2;}
void draw(){
clear();stroke(255);strokeWeight(3);
for(float i=0;i&lt;6.28;i+=.0523){
float r=200*(1+cos(i)*sin(t)*2),s=200*(1+cos(i+.0523)*sin(t)*2);
for(float j=0;j&lt;6.28;j+=0.419)line(x+r*cos(i+j),y+r*sin(i+j),x+s*cos(i+.0523+j),y+s*sin(i+.0523+j));
}t+=.03;
}
</code></pre>
</div></details>
<h2 id="フラクタル"><a class="header" href="#フラクタル">フラクタル</a></h2>
<p><img src="ProcessingSample/img/frac.png" alt="画面" title="画面" /></p>
<details><summary>ソースコード</summary><div>
<pre><code class="language-java">float t=1;
int cnt=0;
void setup(){
  fullScreen();
}

void d(float cx,float cy,float s,int c,float rd){
  cnt++;
  int r=255,g=255,b=255;
  fill(r,g,b);
  float x1=cx+cos(0+rd)*s,y1=cy+sin(0+rd)*s;
  float x2=cx+cos(PI*2/3+rd)*s,y2=cy+sin(PI*2/3+rd)*s;
  float x3=cx+cos(PI*4/3+rd)*s,y3=cy+sin(PI*4/3+rd)*s;
  triangle(x1,y1,x2,y2,x3,y3);
  
  s/=2;
  x1=cx+cos(0+rd)*s;y1=cy+sin(0+rd)*s;
  x2=cx+cos(PI*2/3+rd)*s;y2=cy+sin(PI*2/3+rd)*s;
  x3=cx+cos(PI*4/3+rd)*s;y3=cy+sin(PI*4/3+rd)*s;
  if(c&gt;0){
    //d(cx,cy,s,c-1,rd);
    d(x1,y1,s,c-1,rd);
    d(x2,y2,s,c-1,rd);
    d(x3,y3,s,c-1,rd);
  }
}

void draw(){
  cnt=0;
  textSize(100);
  background(0);
  fill(255);
  d(displayWidth/2,displayHeight/2,1000,6,PI/6);
  t=PI/3;
}
</code></pre>
</div></details>
<h2 id="ほかの作品"><a class="header" href="#ほかの作品">ほかの作品</a></h2>
<h3 id="openprocessing"><a class="header" href="#openprocessing">OpenProcessing</a></h3>
<p><a href="https://openprocessing.org/">OpenProcessing</a>というサイトにはProcessingを使用した作品が投稿されています</p>
<h3 id="つぶやきprocessing"><a class="header" href="#つぶやきprocessing">つぶやきProcessing</a></h3>
<p><img src="ProcessingSample/img/twitter.png" alt="画面" title="画面" /></p>
<p>一つのツイートに収まるソースコードで作品を作る，#つぶやきProcessing というハッシュタグが存在します．ハッシュタグを検索すれば作品がたくさん出てきます．また，ハッシュタグさえ付ければ誰でも投稿が可能なので挑戦してみるのも良いでしょう．</p>
<p>次のプログラムはつぶやきProcessingの例です．</p>
<pre><code class="language-java">float t,e,i,j;void setup(){size(900,600);}void draw(){t+=.017;e+=.1;clear();noStroke();for(i=0;i&lt;32;i++)for(j=1;j&lt;5;j++){float d=1-j/25,c=i*0.196+t*(2+j/3);float x=cos(c)*100*j,y=sin(c)*100*j;ellipse(450+x*cos(e/j)+y*sin(d)*sin(e/j),300+y*cos(d),10*j,10*j);}}
</code></pre>
<p><a href="https://twitter.com/Shibak3333n/status/1418192071987400713">ツイート例</a></p>
<p>このような数式などを使った幾何学的な作品はジェネラティブアート(Generative Art)と呼びます．Processingはジェネラティブアートをするのに手軽な言語です．</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="git--github-講座"><a class="header" href="#git--github-講座">Git / GitHub 講座</a></h1>
<p>ここではGitとGitHubの使い方について解説します。
Gitはバージョン管理システムと呼ばれるもので、あなたが書いたプログラムのコード(ソースコード)を<strong>円滑に</strong>管理することができます。
ソースコード以外にもテキストファイルなら何でも管理することができ、小説やレポートなどを管理することもできます。
現在、IT業界の<strong>デファクト・スタンダード</strong>となっており<strong>ITエンジニア･ITエンジニアになりたい人全員が使用しています。</strong>
さらに複数人での共同開発に向いており、会社･部活･サークルなどで共同開発するときにほぼ必ず使われます。</p>
<h2 id="バージョン管理の利点"><a class="header" href="#バージョン管理の利点">バージョン管理の利点</a></h2>
<p>レポートやソースコードを管理するとき、｢もしかしたら前のものに戻したいからバックアップを取っておこう｣みたいに思ったことは無いでしょうか？
その場合、ファイル名に日付を付けたり番号をつけたりすると思いますが、大抵の場合こうなります。</p>
<ul>
<li>提出レポート(1).docx</li>
<li>提出レポート_001.docx</li>
<li>提出レポート_2021-04-22.docx</li>
<li>提出レポート_最新.docx</li>
<li>提出レポート_最終版.docx</li>
<li>提出レポート_最終版_02.docx</li>
<li>提出レポート_最終版_提出済み.docx</li>
</ul>
<p>こうなってしまうとどのファイルが最新なのか、どのファイルが最後から2番目のファイルなのかが分かりません。
Gitはこのような面倒なバージョン管理をすべて行ってくれます。一般的にGitの利点は以下のとおりです。</p>
<ul>
<li>各変更をバージョンとして記録し、それをいつでも表示したりバージョンを戻したりできる</li>
<li>いつ誰がどこを変更したかが表示できる(差分管理･表示)</li>
<li>なんのために変更したのか理由を記入できる</li>
</ul>
<p><img src="git/./img/commit-list.png" alt="コミットの一覧" />
<img src="git/./img/commit-diff.png" alt="差分" /></p>
<p>他にもGitは <strong>複数人での共同管理に対応しており、</strong> 複数人で同時に1つのファイルを編集したとしてもきちんと統合することができます。</p>
<h2 id="githubとは"><a class="header" href="#githubとは">GitHubとは</a></h2>
<p>Gitがバージョン管理システムならばGitHubは何でしょうか？
先程、Gitでは複数人での共同管理に対応していると言いましたが、共同管理するにはGitで管理しているデータをサーバー上にアップロードし、共有する必要があります。
<strong>サーバーというのは個人が簡単に運用ができるものではなく、</strong> サーバーを借りたり契約する必要があり、運用にコスト(お金)がかかってしまいます。
GitHubはそういった悩みを解消するサービスです。GitHubは巨大なGitサーバーのようなもので、 <strong>基本的に無料で</strong> サービスを利用できます。
他にもGitHub独自の機能を有しており、共同開発するときにはほぼ必須のサービスとなっています。GitHubに類似したサービスとして、GitLabやBitbucketなどがあります。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="git--github-を始める準備"><a class="header" href="#git--github-を始める準備">Git / GitHub を始める準備</a></h1>
<h2 id="gitのインストール"><a class="header" href="#gitのインストール">Gitのインストール</a></h2>
<h3 id="windowswsl2共通"><a class="header" href="#windowswsl2共通">Windows･WSL2共通</a></h3>
<p><a href="https://git-scm.com/download/win">こちらのリンク</a>からインストーラをダウンロードし、インストーラを実行して画面の指示に従ってください。
なお、途中で使用するテキストエディタを選択する場面がありますが、 <strong>デフォルトではVimが選択されているため</strong> 、別のエディタを選択してください。
(VimはCLI上で動作するテキストエディタですが、扱いが非常に難しいため初心者にはおすすめしません。)おすすめはVSCode(入っていれば)です。</p>
<h3 id="ubuntuwsl2の場合"><a class="header" href="#ubuntuwsl2の場合">Ubuntu(WSL2)の場合</a></h3>
<p>以下のコマンド実行でインストールできます。
(余談ですがLinuxは1コマンドで何でもインストールすることができるのが強みです。)</p>
<pre><code class="language-shell">sudo apt update
sudo apt install git
</code></pre>
<p>GitではGitHubなどのリモートGitサーバーの認証情報を扱う場面がありますが、WSL上のGitではそれを保持することができないため、
WindowsにインストールしたGit for Windowsを用いて認証情報を保存します。以下のコマンドで設定してください。
(なお、以下の設定はデフォルトのパスにGit for Windowsをインストールした場合のコマンドです。変更した場合は適宜読み替えてください。)</p>
<pre><code class="language-shell">git config --global credential.helper &quot;/mnt/c/Program\ Files/Git/mingw64/libexec/git-core/git-credential-manager.exe&quot;
</code></pre>
<h3 id="macosの場合"><a class="header" href="#macosの場合">macOSの場合</a></h3>
<p>App StoreからXCodeをイントールすれば勝手についてきます。
しかし、ついてくるものはバージョンが古いためHomebrewからインストールしましょう。</p>
<pre><code class="language-shell">brew update
brew install git
</code></pre>
<h2 id="githubのアカウント登録"><a class="header" href="#githubのアカウント登録">GitHubのアカウント登録</a></h2>
<p><a href="https://github.com/join">ここから</a>GitHubのアカウント登録を行ってください。
(GitHubは利用規約で複数アカウントの所持が禁止されているため解説できません。申し訳ありません。)</p>
<h2 id="名前とメールアドレスの設定"><a class="header" href="#名前とメールアドレスの設定">名前とメールアドレスの設定</a></h2>
<p>Gitで使用する名前とメールアドレスを設定します。
名前はお好きに決めて構いませんが、メールアドレスはGitHubに登録したものを使用する必要があります。
この名前とメールアドレスは全世界に公開されます(GitHubにデータを上げる場合)。
もしも自分のメールアドレスが晒されるのが嫌だと言う場合は、<a href="https://github.com/settings/emails">GitHubの設定のEmailsタブ</a>にあるメールアドレスを使用してください。</p>
<p><img src="git/./img/github-noreply-email.png" alt="GitHubの返信不可能メールアドレス" /></p>
<p>ターミナル上で以下のコマンド実行します。</p>
<pre><code class="language-shell">git config --global user.name &lt;名前&gt;
git config --global user.email &lt;メールアドレス&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gitの概要"><a class="header" href="#gitの概要">Gitの概要</a></h1>
<h2 id="gitの仕組み"><a class="header" href="#gitの仕組み">Gitの仕組み</a></h2>
<p>Gitはバージョン管理システムだと言いましたが、Gitどのようにバージョンを管理しているのでしょうか。
Gitは <strong>スナップショット(Snapshot)</strong> を取ることによってバージョンを管理しています。</p>
<p>Gitにバージョンを記録するとき、その時点での全てのファイルの状態のスナップショットを撮ります。
そしてバージョンとしてそのスナップショットへの参照を記録します。
もしすでにスナップショットが撮られていて、変更がないファイルの場合はスナップショットは撮らずに過去のスナップショットを使いまします。</p>
<p><img src="git/./img/snapshot.svg" alt="スナップショットが記録される様子" /></p>
<p><strong>つまりGitはバージョンごとのファイルのデータを全て記録しています。</strong>
そのため過去のバージョンのファイルを表示する時、Gitは過去のバージョンに記録されているスナップショットの参照からファイルデータを表示しているだけなのです。</p>
<h2 id="gitは永続的"><a class="header" href="#gitは永続的">Gitは永続的</a></h2>
<p>Gitは基本的にデータを追加していくだけです。
データの削除は行われず、一度記録されたデータは永久的に残ります。<sup class="footnote-reference"><a href="#1">1</a></sup>
これは試行錯誤を安全に行えるため、Git(バージョン管理システム)の利点となります。
<strong>しかし、何かしらの機密情報(パスワードやトークンなど)を間違えて記録してしまうと削除が非常に難しくなります。</strong>
Git/GitHubを利用する際はその点に留意して利用してください。</p>
<h2 id="リポジトリ"><a class="header" href="#リポジトリ">リポジトリ</a></h2>
<p>Gitのバージョン管理は <strong>リポジトリ(Repository)</strong> という単位で行われます。
ファイルの変更履歴などの情報は全てリポジトリに記録されます。</p>
<p>リポジトリの実態は<code>.git</code>というディレクトリです。
Gitの管理下(=リポジトリの管理下)にあるディレクトリにはこの<code>.git</code>というディレクトリが存在します。</p>
<p><img src="git/./img/git-dotdir.png" alt=".gitというディレクトリ" /></p>
<p><strong>この<code>.git</code>にはリポジトリのあらゆるデータが格納されているため、これを削除してしまうとリポジトリも消えてしまいます。
注意しましょう。</strong></p>
<h2 id="ローカルリポジトリとリモートリポジトリ"><a class="header" href="#ローカルリポジトリとリモートリポジトリ">ローカルリポジトリとリモートリポジトリ</a></h2>
<p>Gitは複数人での共同管理に対応しています。
この共同管理は1つのデータを複数のリポジトリで共有することで実現しています。
リポジトリは <strong>ローカルリポジトリ</strong> と <strong>リモートリポジトリ</strong> の2種類に分類できます。</p>
<p>ローカルリポジトリは自分のPC上に置いておくリポジトリで、共同管理者一人ひとりがPC上に配置します。
対してリモートリポジトリはサーバ等の複数人でアクセスできる環境に置かれ、このリモートリポジトリを介して共同管理者はリポジトリのデータをやり取りします。</p>
<p><img src="git/./img/local-remote-repository.svg" alt="ローカルリポジトリとリモートリポジトリの関係" /></p>
<p>また、ローカルリポジトリのデータをリモートリポジトリにアップロードすることを <strong>プッシュ(Push)</strong> 、リモートリポジトリのデータをローカルリポジトリにダウンロードすることを <strong>フェッチ(Fetch)</strong> と言います。
詳しくは後述しますが、覚えておきましょう。</p>
<h2 id="コミット"><a class="header" href="#コミット">コミット</a></h2>
<p>ファイルデータのスナップショットを撮って、バージョンを記録することを <strong>コミット(Commit)</strong> と言います。
この表現は非常に多く出てくるので覚えておきましょう。</p>
<h2 id="gitにおける3つの場所"><a class="header" href="#gitにおける3つの場所">Gitにおける3つの場所</a></h2>
<p>リポジトリには3つの場所が存在します。
それは <strong>作業ディレクトリ(Working Directory)</strong> 、 <strong>ステージングエリア(Staging Area)</strong> 、 <strong><code>.git</code>ディレクトリ(リポジトリ)</strong> です。
<strong>作業ディレクトリ</strong> は現在ディスク上に存在するファイルのことで、実際に作業しているディレクトリを指します。
<strong>ステージングエリア</strong> はコミットの準備をするための場所で、ここに置いたファイルがコミットに含まれます。
<strong><code>.git</code>ディレクトリ</strong> はコミットしたバージョンが含まれます。</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>特殊な管理コマンドを使用したり、ガベージコレクションといった操作を行うと、データが削除されることがあります。</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="初めてのコミット"><a class="header" href="#初めてのコミット">初めてのコミット</a></h1>
<p>早速Gitでコミットをしてみましょう。</p>
<h2 id="リポジトリを作る"><a class="header" href="#リポジトリを作る">リポジトリを作る</a></h2>
<p>とりあえず作業用に適当なリポジトリを作ってみます。
Windowsを使用している場合はGit Bashを、それ以外を使用している場合は普段使用しているターミナル<sup class="footnote-reference"><a href="#1">1</a></sup>を開きましょう。
表示されるのは俗に言う「黒い画面」です。もしかしたらこの黒い画面に恐怖心がある方もいるかも知れませんが、頑張ってください。</p>
<p><img src="git/./img/terminal.png" alt="ターミナル" /></p>
<p>上記のスクリーンショットは若干違う表示の場合もあると思いますが、基本的に<code>&gt;</code>や<code>$</code>みたいな表示があり、
そこにテキスト(コマンド)を入力することができるようになっているはずです。</p>
<p>コマンドを入力する準備ができたら、リポジトリとして作業するためのディレクトリを作ります。
名前は何でも良いですが、ここでは<code>test</code>とします。</p>
<pre><code class="language-shell">mkdir test
</code></pre>
<p>ディレクトリを作ったらカレントディレクトリをそこに移動します。</p>
<pre><code class="language-shell">cd test
</code></pre>
<p>移動したらリポジトリを作ってみましょう。
Gitのコマンドは全て<code>git &lt;サブコマンド名&gt;</code>というような形式で、
リポジトリを作る場合は<code>git init</code>というコマンドを使用します。
<code>init</code>は <strong>Initialize</strong> の略で、初期化といった意味があります。
ITの世界では頻繁に使用される略語のため、覚えておくと良いです。</p>
<pre><code class="language-shell">git init
</code></pre>
<p>リポジトリの作成に成功すると、
<code>Initialized empty Git repository in &lt;カレントディレクトリ&gt;/.git/</code>
というメッセージが出力されるはずです。</p>
<p><a href="git/02_git_summary.html#%E3%83%AA%E3%83%9D%E3%82%B8%E3%83%88%E3%83%AA">前回のリポジトリの説明</a>で書いたとおり、リポジトリの実体は<code>.git</code>というディレクトリです。
<code>git init</code>はこの<code>.git</code>ディレクトリを作成するコマンドです。
そのため、ディレクトリにあるファイル・ディレクトリを表示させる<code>ls</code>コマンドを使ってカレントディレクトリの中身を表示すると、<code>.git</code>が新たに作成されています。</p>
<p><img src="git/./img/git-dotdir-init.png" alt="リポジトリ作成直後のディレクトリの様子" /></p>
<h2 id="新しくファイルを作ってみる"><a class="header" href="#新しくファイルを作ってみる">新しくファイルを作ってみる</a></h2>
<p>リポジトリが作成できたら、そこに何かファイルを作ってみましょう。
エクスプローラーやFinderなどのファイルマネージャーから「新規作成」で作ってもいいですし、
VSCodeなどのテキストエディタで作ってもいいですし、
<code>touch</code>コマンドとリダイレクトを駆使して作っても構いません。とにかく何かしらファイルを作ります。
ただしできる限りテキストファイルにしてください。Wordファイルや画像ファイルはGitで管理するにはあまり都合がよくありません。<sup class="footnote-reference"><a href="#2">2</a></sup></p>
<p><img src="git/./img/create-test-file.png" alt="新しく作成したファイル" /></p>
<p>これで作業ディレクトリにファイルが新しく追加されました。
Gitは作業ディレクトリ上での変更をきちんと認識しています。
現在のリポジトリの状態を見るには<code>git status</code>というコマンドを使用します。</p>
<p><img src="git/./img/git-status.png" alt="git statusコマンドの実行結果" /></p>
<p>一段落目は今どのブランチ(branch)に居るかの説明です。ブランチの解説は後でしますが、おそらく<code>master</code>か<code>main</code>になっていると思います。</p>
<p>二段落目はこのリポジトリにはまだコミットがされていないことを表しています。</p>
<p>三段落目が重要です。ここでは作業ディレクトリやステージングエリアにあるファイルの状態を表示しています。
今は<code>Untracked</code>なファイルとして<code>test.txt</code>が表示されています。
<code>Untracked</code>なファイルはまだGitで管理されていないファイルのことです。
<code>test.txt</code>は作成したばかりで、コミット等も一度も行っていないため<code>Untracked</code>なファイルとなっています。</p>
<p>四段落目ではコミットすべきファイルはないが(ステージングエリアにまだファイルを追加していないため)、<code>Untracked</code>なファイルが存在していることを表しています。</p>
<h2 id="ステージングエリアにファイルを追加する"><a class="header" href="#ステージングエリアにファイルを追加する">ステージングエリアにファイルを追加する</a></h2>
<p>リポジトリへコミットするには始めにステージングエリアに変更を追加する必要があります。
ステージングエリアはコミットをするための準備をする場所です。
始めは面倒だと感じるかもしれませんが、作業ディレクトリで加えた複数の変更からコミットした変更を取捨選択するには非常に便利です。</p>
<p>ステージングエリアへの追加は<code>git add</code>というコマンドを使用します。
追加という意味でコマンド名が<code>add</code>なのでとても分かりやすいですね。
先程作成した<code>test.txt</code>を追加するには以下のコマンドを実行します。</p>
<pre><code class="language-shell">git add test.txt
</code></pre>
<p>追加したいファイルが複数ある場合は<code>git add</code>を複数回実行するか、<code>git add</code>の後にスペース区切りでファイルを複数指定します。</p>
<p>正しくステージングエリアに変更が追加されたかどうかを見るには例のごとく<code>git status</code>を使用します。</p>
<p><img src="git/./img/git-status-staged.png" alt="ステージング後のgit statusコマンドの実行結果" /></p>
<p>先程赤色で<code>Untracked</code>と表示されていた<code>test.txt</code>が新しいファイルとして緑色で表示されています。
緑色の表示はステージングエリアにある変更を表しています。
ここで重要なのが、<code>git add</code>は <strong>コマンド実行時の変更をステージングエリアに追加している</strong> ということです。
ステージングエリアへ追加した後に作業ディレクトリに再び変更を加えてもステージングエリアにその変更が伝わることはありません。
再びステージングエリアへ追加する場合は<code>git add</code>をもう一度実行してください。</p>
<h2 id="コミットする"><a class="header" href="#コミットする">コミットする</a></h2>
<p>いよいよコミットをしてみましょう。
コミットをするには名前の通り<code>git commit</code>というコマンドを使用します。
コミットするときには <strong>コミットメッセージ</strong> というものを必ず含める必要があります。<sup class="footnote-reference"><a href="#3">3</a></sup>
コミットメッセージにはそのコミットでは何をしたかを端的に記すと良いです。
以下のコマンドでコミットメッセージを指定してコミットすることが出来ます。</p>
<pre><code class="language-shell">git commit -m '&lt;コミットメッセージ&gt;'
</code></pre>
<p>お疲れさまです、初めてのコミットが出来ました！！</p>
<p>きちんとコミットが出来たかを見るには<code>git log</code>コマンドを使用します。
このコマンドはこれまでのコミット履歴を見ることが出来ます。
履歴にはコミットメッセージ、コミットした日時、コミットした人、コミットハッシュがデフォルトで表示されます。
コミットハッシュはそのコミットを指し示すIDのようなもので、コミットごとに異なり、基本的にリポジトリ内で重複することはありません。</p>
<p><img src="git/./img/git-log.png" alt="git logの実行結果" /></p>
<h2 id="開発の流れ"><a class="header" href="#開発の流れ">開発の流れ</a></h2>
<p>ここでGitを使った開発の流れをおさらいしてみましょう。</p>
<ol>
<li><code>git init</code>でリポジトリを作る</li>
<li>リポジトリ上でプログラミングする(ファイルを作る)</li>
<li>きりの良いところで<code>git add</code>で変更をステージングエリアに追加する</li>
<li><code>git commit</code>でコミットする</li>
<li>2に戻る</li>
</ol>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>WSL2ならWindows Terminalなど、macOSならターミナルやiTerm2など、Linuxならそれぞれの端末のことです。</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>管理できないわけではありませんが、差分表示などの機能を利用できなくなります。</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>実は必須ではないのですが、基本的にはコミットメッセージがないとエラーになります。</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="初めてのプッシュ"><a class="header" href="#初めてのプッシュ">初めてのプッシュ</a></h1>
<p><a href="git/03_first_git_commit.html">前回</a>はGitでのリポジトリの作成とコミットまでを行いました。
ここまででローカル(自分のPC)上でGitを運用することができるようになりました。
しかし、Gitはインターネット等を介したリモートリポジトリを使うことによって真価を発揮します。
ローカル上で作業した結果をリモートにアップロードすることによって他の人に自分の成果を簡単に共有したり、ローカル上のデータが飛んだときのバックアップにすることもできます。
ここではGitHubを用いてリポジトリを作り、プッシュするところまでを行います。</p>
<h2 id="リポジトリを作る-1"><a class="header" href="#リポジトリを作る-1">リポジトリを作る</a></h2>
<p>ローカルで最初に作業したのと同じようにリモートでも最初にリポジトリを作成するところから始めます。
<a href="https://repo.new">このリンク</a>か<code>github.com</code>にアクセスし、右上の「+」ボタンから「New repository」を選択して新規リポジトリ作成画面を開きましょう。</p>
<p><img src="git/./img/github-new-repository.png" alt="GitHubのリポジトリ新規作成画面" /></p>
<p>入力欄がたくさんありますが、必要なのは「Repository name」のみです。
ここでリポジトリ名を決めましょう。
名前は好きなように設定可能ですが、
リポジトリ名がそのままURLになるためむやみに変更したり、
あまり関係のない名前を付けるのはやめましょう。
なお、リポジトリ名として使えるのは半角英数字とハイフン(<code>-</code>)とアンダースコア(<code>_</code>)のみです。
リポジトリ名を決めたら後は特に変更せずに一番下の「Create repository」をクリックしてリポジトリを作成します。<sup class="footnote-reference"><a href="#1">1</a></sup></p>
<p><img src="git/./img/github-init-repository.png" alt="リポジトリ作成直後の画面" /></p>
<p>「Quick setup」の下にある<code>https://</code>から始まるURLを確認してください。このURLは今作成したリポジトリへのURLです。<code>https://</code>から始まっていない場合はその左のHTTPS/SSHのボタンからHTTPSを選択してください。<sup class="footnote-reference"><a href="#2">2</a></sup>
このURLは後で使用するので右のボタンからコピーしておきましょう。</p>
<h1 id="リモートリポジトリの追加"><a class="header" href="#リモートリポジトリの追加">リモートリポジトリの追加</a></h1>
<p>GitHub上にリポジトリが作成できたら、次はローカルリポジトリにリモートリポジトリの追加をしてみましょう。</p>
<p>リモートリポジトリ関連の設定は<code>git remote</code>というコマンドを使用します。
今回は新しくリモートリポジトリを追加するので<code>git remote add</code>というコマンドになります。</p>
<pre><code class="language-shell">git remote add origin &lt;リモートリポジトリへのURL&gt;
</code></pre>
<p>リモートリポジトリには分かりやすいように名前を付けることが出来ます。<code>origin</code>はリモートリポジトリの名前です。好きな名前にすることが出来ますが、Gitでは大元になるリモートリポジトリ名を慣例的に<code>origin</code>にしています。<sup class="footnote-reference"><a href="#3">3</a></sup></p>
<p>リモートリポジトリに名前を付けることができることから分かるように、リモートリポジトリは複数個登録することが可能です。しかし、1つか2つ程度のリモートリポジトリしか登録することはないでしょう。なぜなら1つのリモートリポジトリを大元として中央集権的なモデルにしたほうが管理がしやすいためです。</p>
<p>無事に追加ができたかどうかは<code>git remote show</code>で確認することが出来ます。<code>git remote show</code>で現在のリモートリポジトリの一覧が、<code>git remote show &lt;リモートリポジトリ名&gt;</code>でそのリモートリポジトリの詳細を確認することが出来ます。</p>
<h1 id="プッシュ"><a class="header" href="#プッシュ">プッシュ</a></h1>
<p>リモートリポジトリが登録できたらいよいよプッシュをしてみます。
プッシュを行うコマンドは文字通り<code>git push</code>です。</p>
<pre><code class="language-shell">git push -u origin master
</code></pre>
<p><code>origin</code>は先程のリモートリポジトリ名、<code>master</code>はブランチ名です。ブランチの解説は後に行うので、今は気にしないでください。
<code>-u</code>オプションは<code>--set-upstream</code>の略です。
これは上流ブランチと呼ばれるものを設定するオプションですが、少し難しい概念なため、解説は割愛します。
気になる方は調べてみてください。</p>
<p>Git for Windowsを使用している場合はプッシュするとログインを求められる画面が表示されるはずなので、画面に従ってログインをしてください。
macOSやLinuxでGitを操作している場合はユーザ名とパスワードを求められます。
ユーザ名はGitHubのユーザ名を、パスワードには <strong>パスワードではなく、Personal Access Tokenと呼ばれるトークン</strong> を入力します。
詳しくは<a href="https://docs.github.com/ja/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token">このページ</a>を参照してください。</p>
<p>無事にプッシュが出来たらGitHubのリポジトリへアクセス(またはページの更新)をしてみましょう。成功していれば先程と異なる画面が表示されるはずです！</p>
<p><img src="git/./img/github-after-push-repository.png" alt="プッシュ後のGitHubのリポジトリ画面" /></p>
<p>GitHubのリポジトリ画面ではコミット履歴や各コミットでの変更点、ファイルの閲覧をすることが出来ます。色々触ってみて遊んでみてください！</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>リポジトリ名の下のPublic/Privateは他人からのリポジトリの見え方を選択する部分です。Publicにすると全世界に公開されますし、Privateは自分(と招待した人)しか見ることが出来ません。</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>SSHでもプッシュは可能ですが、少しセットアップが面倒です。詳しくは調べてみてください。</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p><code>origin</code>には起源や原点や由来といった意味があります。</p>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
